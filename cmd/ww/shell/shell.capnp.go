// Code generated by capnpc-go. DO NOT EDIT.

package shell

import (
	context "context"
	strconv "strconv"

	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
)

type EventLoop capnp.Client

// EventLoop_TypeID is the unique identifier for the type EventLoop.
const EventLoop_TypeID = 0xef0707db310901e8

func (c EventLoop) AddActor(ctx context.Context, params func(EventLoop_addActor_Params) error) (EventLoop_addActor_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xef0707db310901e8,
			MethodID:      0,
			InterfaceName: "shell.capnp:EventLoop",
			MethodName:    "addActor",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(EventLoop_addActor_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return EventLoop_addActor_Results_Future{Future: ans.Future()}, release

}

func (c EventLoop) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c EventLoop) String() string {
	return "EventLoop(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c EventLoop) AddRef() EventLoop {
	return EventLoop(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c EventLoop) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c EventLoop) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c EventLoop) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (EventLoop) DecodeFromPtr(p capnp.Ptr) EventLoop {
	return EventLoop(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c EventLoop) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c EventLoop) IsSame(other EventLoop) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c EventLoop) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c EventLoop) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A EventLoop_Server is a EventLoop with a local implementation.
type EventLoop_Server interface {
	AddActor(context.Context, EventLoop_addActor) error
}

// EventLoop_NewServer creates a new Server from an implementation of EventLoop_Server.
func EventLoop_NewServer(s EventLoop_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(EventLoop_Methods(nil, s), s, c)
}

// EventLoop_ServerToClient creates a new Client from an implementation of EventLoop_Server.
// The caller is responsible for calling Release on the returned Client.
func EventLoop_ServerToClient(s EventLoop_Server) EventLoop {
	return EventLoop(capnp.NewClient(EventLoop_NewServer(s)))
}

// EventLoop_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func EventLoop_Methods(methods []server.Method, s EventLoop_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xef0707db310901e8,
			MethodID:      0,
			InterfaceName: "shell.capnp:EventLoop",
			MethodName:    "addActor",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.AddActor(ctx, EventLoop_addActor{call})
		},
	})

	return methods
}

// EventLoop_addActor holds the state for a server call to EventLoop.addActor.
// See server.Call for documentation.
type EventLoop_addActor struct {
	*server.Call
}

// Args returns the call's arguments.
func (c EventLoop_addActor) Args() EventLoop_addActor_Params {
	return EventLoop_addActor_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c EventLoop_addActor) AllocResults() (EventLoop_addActor_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return EventLoop_addActor_Results(r), err
}

// EventLoop_List is a list of EventLoop.
type EventLoop_List = capnp.CapList[EventLoop]

// NewEventLoop creates a new list of EventLoop.
func NewEventLoop_List(s *capnp.Segment, sz int32) (EventLoop_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[EventLoop](l), err
}

type EventLoop_addActor_Params capnp.Struct

// EventLoop_addActor_Params_TypeID is the unique identifier for the type EventLoop_addActor_Params.
const EventLoop_addActor_Params_TypeID = 0xd91363a073d0485a

func NewEventLoop_addActor_Params(s *capnp.Segment) (EventLoop_addActor_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return EventLoop_addActor_Params(st), err
}

func NewRootEventLoop_addActor_Params(s *capnp.Segment) (EventLoop_addActor_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return EventLoop_addActor_Params(st), err
}

func ReadRootEventLoop_addActor_Params(msg *capnp.Message) (EventLoop_addActor_Params, error) {
	root, err := msg.Root()
	return EventLoop_addActor_Params(root.Struct()), err
}

func (s EventLoop_addActor_Params) String() string {
	str, _ := text.Marshal(0xd91363a073d0485a, capnp.Struct(s))
	return str
}

func (s EventLoop_addActor_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (EventLoop_addActor_Params) DecodeFromPtr(p capnp.Ptr) EventLoop_addActor_Params {
	return EventLoop_addActor_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s EventLoop_addActor_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s EventLoop_addActor_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s EventLoop_addActor_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s EventLoop_addActor_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s EventLoop_addActor_Params) Handler() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s EventLoop_addActor_Params) HasHandler() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s EventLoop_addActor_Params) HandlerBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s EventLoop_addActor_Params) SetHandler(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// EventLoop_addActor_Params_List is a list of EventLoop_addActor_Params.
type EventLoop_addActor_Params_List = capnp.StructList[EventLoop_addActor_Params]

// NewEventLoop_addActor_Params creates a new list of EventLoop_addActor_Params.
func NewEventLoop_addActor_Params_List(s *capnp.Segment, sz int32) (EventLoop_addActor_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[EventLoop_addActor_Params](l), err
}

// EventLoop_addActor_Params_Future is a wrapper for a EventLoop_addActor_Params promised by a client call.
type EventLoop_addActor_Params_Future struct{ *capnp.Future }

func (f EventLoop_addActor_Params_Future) Struct() (EventLoop_addActor_Params, error) {
	p, err := f.Future.Ptr()
	return EventLoop_addActor_Params(p.Struct()), err
}

type EventLoop_addActor_Results capnp.Struct

// EventLoop_addActor_Results_TypeID is the unique identifier for the type EventLoop_addActor_Results.
const EventLoop_addActor_Results_TypeID = 0xbbafeb3e01e71170

func NewEventLoop_addActor_Results(s *capnp.Segment) (EventLoop_addActor_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return EventLoop_addActor_Results(st), err
}

func NewRootEventLoop_addActor_Results(s *capnp.Segment) (EventLoop_addActor_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return EventLoop_addActor_Results(st), err
}

func ReadRootEventLoop_addActor_Results(msg *capnp.Message) (EventLoop_addActor_Results, error) {
	root, err := msg.Root()
	return EventLoop_addActor_Results(root.Struct()), err
}

func (s EventLoop_addActor_Results) String() string {
	str, _ := text.Marshal(0xbbafeb3e01e71170, capnp.Struct(s))
	return str
}

func (s EventLoop_addActor_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (EventLoop_addActor_Results) DecodeFromPtr(p capnp.Ptr) EventLoop_addActor_Results {
	return EventLoop_addActor_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s EventLoop_addActor_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s EventLoop_addActor_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s EventLoop_addActor_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s EventLoop_addActor_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s EventLoop_addActor_Results) Mailbox() Mailbox {
	p, _ := capnp.Struct(s).Ptr(0)
	return Mailbox(p.Interface().Client())
}

func (s EventLoop_addActor_Results) HasMailbox() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s EventLoop_addActor_Results) SetMailbox(v Mailbox) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// EventLoop_addActor_Results_List is a list of EventLoop_addActor_Results.
type EventLoop_addActor_Results_List = capnp.StructList[EventLoop_addActor_Results]

// NewEventLoop_addActor_Results creates a new list of EventLoop_addActor_Results.
func NewEventLoop_addActor_Results_List(s *capnp.Segment, sz int32) (EventLoop_addActor_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[EventLoop_addActor_Results](l), err
}

// EventLoop_addActor_Results_Future is a wrapper for a EventLoop_addActor_Results promised by a client call.
type EventLoop_addActor_Results_Future struct{ *capnp.Future }

func (f EventLoop_addActor_Results_Future) Struct() (EventLoop_addActor_Results, error) {
	p, err := f.Future.Ptr()
	return EventLoop_addActor_Results(p.Struct()), err
}
func (p EventLoop_addActor_Results_Future) Mailbox() Mailbox {
	return Mailbox(p.Future.Field(0, nil).Client())
}

type Mailbox capnp.Client

// Mailbox_TypeID is the unique identifier for the type Mailbox.
const Mailbox_TypeID = 0xbd4bc3d338b68790

func (c Mailbox) NewBuffer(ctx context.Context, params func(Mailbox_newBuffer_Params) error) (Mailbox_newBuffer_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xbd4bc3d338b68790,
			MethodID:      0,
			InterfaceName: "shell.capnp:Mailbox",
			MethodName:    "newBuffer",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Mailbox_newBuffer_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Mailbox_newBuffer_Results_Future{Future: ans.Future()}, release

}

func (c Mailbox) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Mailbox) String() string {
	return "Mailbox(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Mailbox) AddRef() Mailbox {
	return Mailbox(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Mailbox) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Mailbox) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Mailbox) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Mailbox) DecodeFromPtr(p capnp.Ptr) Mailbox {
	return Mailbox(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Mailbox) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Mailbox) IsSame(other Mailbox) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Mailbox) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Mailbox) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Mailbox_Server is a Mailbox with a local implementation.
type Mailbox_Server interface {
	NewBuffer(context.Context, Mailbox_newBuffer) error
}

// Mailbox_NewServer creates a new Server from an implementation of Mailbox_Server.
func Mailbox_NewServer(s Mailbox_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Mailbox_Methods(nil, s), s, c)
}

// Mailbox_ServerToClient creates a new Client from an implementation of Mailbox_Server.
// The caller is responsible for calling Release on the returned Client.
func Mailbox_ServerToClient(s Mailbox_Server) Mailbox {
	return Mailbox(capnp.NewClient(Mailbox_NewServer(s)))
}

// Mailbox_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Mailbox_Methods(methods []server.Method, s Mailbox_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xbd4bc3d338b68790,
			MethodID:      0,
			InterfaceName: "shell.capnp:Mailbox",
			MethodName:    "newBuffer",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.NewBuffer(ctx, Mailbox_newBuffer{call})
		},
	})

	return methods
}

// Mailbox_newBuffer holds the state for a server call to Mailbox.newBuffer.
// See server.Call for documentation.
type Mailbox_newBuffer struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Mailbox_newBuffer) Args() Mailbox_newBuffer_Params {
	return Mailbox_newBuffer_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Mailbox_newBuffer) AllocResults() (Mailbox_newBuffer_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Mailbox_newBuffer_Results(r), err
}

// Mailbox_List is a list of Mailbox.
type Mailbox_List = capnp.CapList[Mailbox]

// NewMailbox creates a new list of Mailbox.
func NewMailbox_List(s *capnp.Segment, sz int32) (Mailbox_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Mailbox](l), err
}

type Mailbox_newBuffer_Params capnp.Struct

// Mailbox_newBuffer_Params_TypeID is the unique identifier for the type Mailbox_newBuffer_Params.
const Mailbox_newBuffer_Params_TypeID = 0xbd4ee25c19bae4a0

func NewMailbox_newBuffer_Params(s *capnp.Segment) (Mailbox_newBuffer_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Mailbox_newBuffer_Params(st), err
}

func NewRootMailbox_newBuffer_Params(s *capnp.Segment) (Mailbox_newBuffer_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Mailbox_newBuffer_Params(st), err
}

func ReadRootMailbox_newBuffer_Params(msg *capnp.Message) (Mailbox_newBuffer_Params, error) {
	root, err := msg.Root()
	return Mailbox_newBuffer_Params(root.Struct()), err
}

func (s Mailbox_newBuffer_Params) String() string {
	str, _ := text.Marshal(0xbd4ee25c19bae4a0, capnp.Struct(s))
	return str
}

func (s Mailbox_newBuffer_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Mailbox_newBuffer_Params) DecodeFromPtr(p capnp.Ptr) Mailbox_newBuffer_Params {
	return Mailbox_newBuffer_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Mailbox_newBuffer_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Mailbox_newBuffer_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Mailbox_newBuffer_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Mailbox_newBuffer_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Mailbox_newBuffer_Params_List is a list of Mailbox_newBuffer_Params.
type Mailbox_newBuffer_Params_List = capnp.StructList[Mailbox_newBuffer_Params]

// NewMailbox_newBuffer_Params creates a new list of Mailbox_newBuffer_Params.
func NewMailbox_newBuffer_Params_List(s *capnp.Segment, sz int32) (Mailbox_newBuffer_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Mailbox_newBuffer_Params](l), err
}

// Mailbox_newBuffer_Params_Future is a wrapper for a Mailbox_newBuffer_Params promised by a client call.
type Mailbox_newBuffer_Params_Future struct{ *capnp.Future }

func (f Mailbox_newBuffer_Params_Future) Struct() (Mailbox_newBuffer_Params, error) {
	p, err := f.Future.Ptr()
	return Mailbox_newBuffer_Params(p.Struct()), err
}

type Mailbox_newBuffer_Results capnp.Struct

// Mailbox_newBuffer_Results_TypeID is the unique identifier for the type Mailbox_newBuffer_Results.
const Mailbox_newBuffer_Results_TypeID = 0x846071f72bde13bb

func NewMailbox_newBuffer_Results(s *capnp.Segment) (Mailbox_newBuffer_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Mailbox_newBuffer_Results(st), err
}

func NewRootMailbox_newBuffer_Results(s *capnp.Segment) (Mailbox_newBuffer_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Mailbox_newBuffer_Results(st), err
}

func ReadRootMailbox_newBuffer_Results(msg *capnp.Message) (Mailbox_newBuffer_Results, error) {
	root, err := msg.Root()
	return Mailbox_newBuffer_Results(root.Struct()), err
}

func (s Mailbox_newBuffer_Results) String() string {
	str, _ := text.Marshal(0x846071f72bde13bb, capnp.Struct(s))
	return str
}

func (s Mailbox_newBuffer_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Mailbox_newBuffer_Results) DecodeFromPtr(p capnp.Ptr) Mailbox_newBuffer_Results {
	return Mailbox_newBuffer_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Mailbox_newBuffer_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Mailbox_newBuffer_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Mailbox_newBuffer_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Mailbox_newBuffer_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Mailbox_newBuffer_Results) Buffer() Buffer {
	p, _ := capnp.Struct(s).Ptr(0)
	return Buffer(p.Interface().Client())
}

func (s Mailbox_newBuffer_Results) HasBuffer() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Mailbox_newBuffer_Results) SetBuffer(v Buffer) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Mailbox_newBuffer_Results_List is a list of Mailbox_newBuffer_Results.
type Mailbox_newBuffer_Results_List = capnp.StructList[Mailbox_newBuffer_Results]

// NewMailbox_newBuffer_Results creates a new list of Mailbox_newBuffer_Results.
func NewMailbox_newBuffer_Results_List(s *capnp.Segment, sz int32) (Mailbox_newBuffer_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Mailbox_newBuffer_Results](l), err
}

// Mailbox_newBuffer_Results_Future is a wrapper for a Mailbox_newBuffer_Results promised by a client call.
type Mailbox_newBuffer_Results_Future struct{ *capnp.Future }

func (f Mailbox_newBuffer_Results_Future) Struct() (Mailbox_newBuffer_Results, error) {
	p, err := f.Future.Ptr()
	return Mailbox_newBuffer_Results(p.Struct()), err
}
func (p Mailbox_newBuffer_Results_Future) Buffer() Buffer {
	return Buffer(p.Future.Field(0, nil).Client())
}

type Buffer capnp.Client

// Buffer_TypeID is the unique identifier for the type Buffer.
const Buffer_TypeID = 0xc385438ec56c4e58

func (c Buffer) Write(ctx context.Context, params func(Buffer_write_Params) error) (Buffer_write_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc385438ec56c4e58,
			MethodID:      0,
			InterfaceName: "shell.capnp:Buffer",
			MethodName:    "write",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Buffer_write_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Buffer_write_Results_Future{Future: ans.Future()}, release

}

func (c Buffer) WriteString(ctx context.Context, params func(Buffer_writeString_Params) error) (Buffer_writeString_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc385438ec56c4e58,
			MethodID:      1,
			InterfaceName: "shell.capnp:Buffer",
			MethodName:    "writeString",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Buffer_writeString_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Buffer_writeString_Results_Future{Future: ans.Future()}, release

}

func (c Buffer) Read(ctx context.Context, params func(Buffer_read_Params) error) (Buffer_read_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc385438ec56c4e58,
			MethodID:      2,
			InterfaceName: "shell.capnp:Buffer",
			MethodName:    "read",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Buffer_read_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Buffer_read_Results_Future{Future: ans.Future()}, release

}

func (c Buffer) Flush(ctx context.Context, params func(Buffer_flush_Params) error) (Buffer_flush_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xc385438ec56c4e58,
			MethodID:      3,
			InterfaceName: "shell.capnp:Buffer",
			MethodName:    "flush",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Buffer_flush_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Buffer_flush_Results_Future{Future: ans.Future()}, release

}

func (c Buffer) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Buffer) String() string {
	return "Buffer(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Buffer) AddRef() Buffer {
	return Buffer(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Buffer) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Buffer) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Buffer) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Buffer) DecodeFromPtr(p capnp.Ptr) Buffer {
	return Buffer(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Buffer) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Buffer) IsSame(other Buffer) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Buffer) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Buffer) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Buffer_Server is a Buffer with a local implementation.
type Buffer_Server interface {
	Write(context.Context, Buffer_write) error

	WriteString(context.Context, Buffer_writeString) error

	Read(context.Context, Buffer_read) error

	Flush(context.Context, Buffer_flush) error
}

// Buffer_NewServer creates a new Server from an implementation of Buffer_Server.
func Buffer_NewServer(s Buffer_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Buffer_Methods(nil, s), s, c)
}

// Buffer_ServerToClient creates a new Client from an implementation of Buffer_Server.
// The caller is responsible for calling Release on the returned Client.
func Buffer_ServerToClient(s Buffer_Server) Buffer {
	return Buffer(capnp.NewClient(Buffer_NewServer(s)))
}

// Buffer_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Buffer_Methods(methods []server.Method, s Buffer_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 4)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc385438ec56c4e58,
			MethodID:      0,
			InterfaceName: "shell.capnp:Buffer",
			MethodName:    "write",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Write(ctx, Buffer_write{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc385438ec56c4e58,
			MethodID:      1,
			InterfaceName: "shell.capnp:Buffer",
			MethodName:    "writeString",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.WriteString(ctx, Buffer_writeString{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc385438ec56c4e58,
			MethodID:      2,
			InterfaceName: "shell.capnp:Buffer",
			MethodName:    "read",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Read(ctx, Buffer_read{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xc385438ec56c4e58,
			MethodID:      3,
			InterfaceName: "shell.capnp:Buffer",
			MethodName:    "flush",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Flush(ctx, Buffer_flush{call})
		},
	})

	return methods
}

// Buffer_write holds the state for a server call to Buffer.write.
// See server.Call for documentation.
type Buffer_write struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Buffer_write) Args() Buffer_write_Params {
	return Buffer_write_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Buffer_write) AllocResults() (Buffer_write_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer_write_Results(r), err
}

// Buffer_writeString holds the state for a server call to Buffer.writeString.
// See server.Call for documentation.
type Buffer_writeString struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Buffer_writeString) Args() Buffer_writeString_Params {
	return Buffer_writeString_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Buffer_writeString) AllocResults() (Buffer_writeString_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer_writeString_Results(r), err
}

// Buffer_read holds the state for a server call to Buffer.read.
// See server.Call for documentation.
type Buffer_read struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Buffer_read) Args() Buffer_read_Params {
	return Buffer_read_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Buffer_read) AllocResults() (Buffer_read_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Buffer_read_Results(r), err
}

// Buffer_flush holds the state for a server call to Buffer.flush.
// See server.Call for documentation.
type Buffer_flush struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Buffer_flush) Args() Buffer_flush_Params {
	return Buffer_flush_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Buffer_flush) AllocResults() (Buffer_flush_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Buffer_flush_Results(r), err
}

// Buffer_List is a list of Buffer.
type Buffer_List = capnp.CapList[Buffer]

// NewBuffer creates a new list of Buffer.
func NewBuffer_List(s *capnp.Segment, sz int32) (Buffer_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Buffer](l), err
}

type Buffer_Status capnp.Struct
type Buffer_Status_Which uint16

const (
	Buffer_Status_Which_ok    Buffer_Status_Which = 0
	Buffer_Status_Which_eof   Buffer_Status_Which = 1
	Buffer_Status_Which_error Buffer_Status_Which = 2
)

func (w Buffer_Status_Which) String() string {
	const s = "okeoferror"
	switch w {
	case Buffer_Status_Which_ok:
		return s[0:2]
	case Buffer_Status_Which_eof:
		return s[2:5]
	case Buffer_Status_Which_error:
		return s[5:10]

	}
	return "Buffer_Status_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Buffer_Status_TypeID is the unique identifier for the type Buffer_Status.
const Buffer_Status_TypeID = 0xb391d0fa84c21d71

func NewBuffer_Status(s *capnp.Segment) (Buffer_Status, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Buffer_Status(st), err
}

func NewRootBuffer_Status(s *capnp.Segment) (Buffer_Status, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Buffer_Status(st), err
}

func ReadRootBuffer_Status(msg *capnp.Message) (Buffer_Status, error) {
	root, err := msg.Root()
	return Buffer_Status(root.Struct()), err
}

func (s Buffer_Status) String() string {
	str, _ := text.Marshal(0xb391d0fa84c21d71, capnp.Struct(s))
	return str
}

func (s Buffer_Status) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Buffer_Status) DecodeFromPtr(p capnp.Ptr) Buffer_Status {
	return Buffer_Status(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Buffer_Status) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Buffer_Status) Which() Buffer_Status_Which {
	return Buffer_Status_Which(capnp.Struct(s).Uint16(0))
}
func (s Buffer_Status) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Buffer_Status) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Buffer_Status) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Buffer_Status) SetOk() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Buffer_Status) SetEof() {
	capnp.Struct(s).SetUint16(0, 1)

}

func (s Buffer_Status) Error() (string, error) {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != error")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Buffer_Status) HasError() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Buffer_Status) ErrorBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Buffer_Status) SetError(v string) error {
	capnp.Struct(s).SetUint16(0, 2)
	return capnp.Struct(s).SetText(0, v)
}

// Buffer_Status_List is a list of Buffer_Status.
type Buffer_Status_List = capnp.StructList[Buffer_Status]

// NewBuffer_Status creates a new list of Buffer_Status.
func NewBuffer_Status_List(s *capnp.Segment, sz int32) (Buffer_Status_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Buffer_Status](l), err
}

// Buffer_Status_Future is a wrapper for a Buffer_Status promised by a client call.
type Buffer_Status_Future struct{ *capnp.Future }

func (f Buffer_Status_Future) Struct() (Buffer_Status, error) {
	p, err := f.Future.Ptr()
	return Buffer_Status(p.Struct()), err
}

type Buffer_write_Params capnp.Struct

// Buffer_write_Params_TypeID is the unique identifier for the type Buffer_write_Params.
const Buffer_write_Params_TypeID = 0xac24ea5bb35da196

func NewBuffer_write_Params(s *capnp.Segment) (Buffer_write_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer_write_Params(st), err
}

func NewRootBuffer_write_Params(s *capnp.Segment) (Buffer_write_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer_write_Params(st), err
}

func ReadRootBuffer_write_Params(msg *capnp.Message) (Buffer_write_Params, error) {
	root, err := msg.Root()
	return Buffer_write_Params(root.Struct()), err
}

func (s Buffer_write_Params) String() string {
	str, _ := text.Marshal(0xac24ea5bb35da196, capnp.Struct(s))
	return str
}

func (s Buffer_write_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Buffer_write_Params) DecodeFromPtr(p capnp.Ptr) Buffer_write_Params {
	return Buffer_write_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Buffer_write_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Buffer_write_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Buffer_write_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Buffer_write_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Buffer_write_Params) Input() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Buffer_write_Params) HasInput() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Buffer_write_Params) SetInput(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// Buffer_write_Params_List is a list of Buffer_write_Params.
type Buffer_write_Params_List = capnp.StructList[Buffer_write_Params]

// NewBuffer_write_Params creates a new list of Buffer_write_Params.
func NewBuffer_write_Params_List(s *capnp.Segment, sz int32) (Buffer_write_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Buffer_write_Params](l), err
}

// Buffer_write_Params_Future is a wrapper for a Buffer_write_Params promised by a client call.
type Buffer_write_Params_Future struct{ *capnp.Future }

func (f Buffer_write_Params_Future) Struct() (Buffer_write_Params, error) {
	p, err := f.Future.Ptr()
	return Buffer_write_Params(p.Struct()), err
}

type Buffer_write_Results capnp.Struct

// Buffer_write_Results_TypeID is the unique identifier for the type Buffer_write_Results.
const Buffer_write_Results_TypeID = 0xd15c12b2b2c5d94e

func NewBuffer_write_Results(s *capnp.Segment) (Buffer_write_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer_write_Results(st), err
}

func NewRootBuffer_write_Results(s *capnp.Segment) (Buffer_write_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer_write_Results(st), err
}

func ReadRootBuffer_write_Results(msg *capnp.Message) (Buffer_write_Results, error) {
	root, err := msg.Root()
	return Buffer_write_Results(root.Struct()), err
}

func (s Buffer_write_Results) String() string {
	str, _ := text.Marshal(0xd15c12b2b2c5d94e, capnp.Struct(s))
	return str
}

func (s Buffer_write_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Buffer_write_Results) DecodeFromPtr(p capnp.Ptr) Buffer_write_Results {
	return Buffer_write_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Buffer_write_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Buffer_write_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Buffer_write_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Buffer_write_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Buffer_write_Results) Status() (Buffer_Status, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Buffer_Status(p.Struct()), err
}

func (s Buffer_write_Results) HasStatus() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Buffer_write_Results) SetStatus(v Buffer_Status) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewStatus sets the status field to a newly
// allocated Buffer_Status struct, preferring placement in s's segment.
func (s Buffer_write_Results) NewStatus() (Buffer_Status, error) {
	ss, err := NewBuffer_Status(capnp.Struct(s).Segment())
	if err != nil {
		return Buffer_Status{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Buffer_write_Results_List is a list of Buffer_write_Results.
type Buffer_write_Results_List = capnp.StructList[Buffer_write_Results]

// NewBuffer_write_Results creates a new list of Buffer_write_Results.
func NewBuffer_write_Results_List(s *capnp.Segment, sz int32) (Buffer_write_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Buffer_write_Results](l), err
}

// Buffer_write_Results_Future is a wrapper for a Buffer_write_Results promised by a client call.
type Buffer_write_Results_Future struct{ *capnp.Future }

func (f Buffer_write_Results_Future) Struct() (Buffer_write_Results, error) {
	p, err := f.Future.Ptr()
	return Buffer_write_Results(p.Struct()), err
}
func (p Buffer_write_Results_Future) Status() Buffer_Status_Future {
	return Buffer_Status_Future{Future: p.Future.Field(0, nil)}
}

type Buffer_writeString_Params capnp.Struct

// Buffer_writeString_Params_TypeID is the unique identifier for the type Buffer_writeString_Params.
const Buffer_writeString_Params_TypeID = 0xeb0e5010d1b59026

func NewBuffer_writeString_Params(s *capnp.Segment) (Buffer_writeString_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer_writeString_Params(st), err
}

func NewRootBuffer_writeString_Params(s *capnp.Segment) (Buffer_writeString_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer_writeString_Params(st), err
}

func ReadRootBuffer_writeString_Params(msg *capnp.Message) (Buffer_writeString_Params, error) {
	root, err := msg.Root()
	return Buffer_writeString_Params(root.Struct()), err
}

func (s Buffer_writeString_Params) String() string {
	str, _ := text.Marshal(0xeb0e5010d1b59026, capnp.Struct(s))
	return str
}

func (s Buffer_writeString_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Buffer_writeString_Params) DecodeFromPtr(p capnp.Ptr) Buffer_writeString_Params {
	return Buffer_writeString_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Buffer_writeString_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Buffer_writeString_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Buffer_writeString_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Buffer_writeString_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Buffer_writeString_Params) Input() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Buffer_writeString_Params) HasInput() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Buffer_writeString_Params) InputBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Buffer_writeString_Params) SetInput(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Buffer_writeString_Params_List is a list of Buffer_writeString_Params.
type Buffer_writeString_Params_List = capnp.StructList[Buffer_writeString_Params]

// NewBuffer_writeString_Params creates a new list of Buffer_writeString_Params.
func NewBuffer_writeString_Params_List(s *capnp.Segment, sz int32) (Buffer_writeString_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Buffer_writeString_Params](l), err
}

// Buffer_writeString_Params_Future is a wrapper for a Buffer_writeString_Params promised by a client call.
type Buffer_writeString_Params_Future struct{ *capnp.Future }

func (f Buffer_writeString_Params_Future) Struct() (Buffer_writeString_Params, error) {
	p, err := f.Future.Ptr()
	return Buffer_writeString_Params(p.Struct()), err
}

type Buffer_writeString_Results capnp.Struct

// Buffer_writeString_Results_TypeID is the unique identifier for the type Buffer_writeString_Results.
const Buffer_writeString_Results_TypeID = 0xfae584cad6e82c9b

func NewBuffer_writeString_Results(s *capnp.Segment) (Buffer_writeString_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer_writeString_Results(st), err
}

func NewRootBuffer_writeString_Results(s *capnp.Segment) (Buffer_writeString_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Buffer_writeString_Results(st), err
}

func ReadRootBuffer_writeString_Results(msg *capnp.Message) (Buffer_writeString_Results, error) {
	root, err := msg.Root()
	return Buffer_writeString_Results(root.Struct()), err
}

func (s Buffer_writeString_Results) String() string {
	str, _ := text.Marshal(0xfae584cad6e82c9b, capnp.Struct(s))
	return str
}

func (s Buffer_writeString_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Buffer_writeString_Results) DecodeFromPtr(p capnp.Ptr) Buffer_writeString_Results {
	return Buffer_writeString_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Buffer_writeString_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Buffer_writeString_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Buffer_writeString_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Buffer_writeString_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Buffer_writeString_Results) Status() (Buffer_Status, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Buffer_Status(p.Struct()), err
}

func (s Buffer_writeString_Results) HasStatus() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Buffer_writeString_Results) SetStatus(v Buffer_Status) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewStatus sets the status field to a newly
// allocated Buffer_Status struct, preferring placement in s's segment.
func (s Buffer_writeString_Results) NewStatus() (Buffer_Status, error) {
	ss, err := NewBuffer_Status(capnp.Struct(s).Segment())
	if err != nil {
		return Buffer_Status{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Buffer_writeString_Results_List is a list of Buffer_writeString_Results.
type Buffer_writeString_Results_List = capnp.StructList[Buffer_writeString_Results]

// NewBuffer_writeString_Results creates a new list of Buffer_writeString_Results.
func NewBuffer_writeString_Results_List(s *capnp.Segment, sz int32) (Buffer_writeString_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Buffer_writeString_Results](l), err
}

// Buffer_writeString_Results_Future is a wrapper for a Buffer_writeString_Results promised by a client call.
type Buffer_writeString_Results_Future struct{ *capnp.Future }

func (f Buffer_writeString_Results_Future) Struct() (Buffer_writeString_Results, error) {
	p, err := f.Future.Ptr()
	return Buffer_writeString_Results(p.Struct()), err
}
func (p Buffer_writeString_Results_Future) Status() Buffer_Status_Future {
	return Buffer_Status_Future{Future: p.Future.Field(0, nil)}
}

type Buffer_read_Params capnp.Struct

// Buffer_read_Params_TypeID is the unique identifier for the type Buffer_read_Params.
const Buffer_read_Params_TypeID = 0x988f94f380d5b032

func NewBuffer_read_Params(s *capnp.Segment) (Buffer_read_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Buffer_read_Params(st), err
}

func NewRootBuffer_read_Params(s *capnp.Segment) (Buffer_read_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Buffer_read_Params(st), err
}

func ReadRootBuffer_read_Params(msg *capnp.Message) (Buffer_read_Params, error) {
	root, err := msg.Root()
	return Buffer_read_Params(root.Struct()), err
}

func (s Buffer_read_Params) String() string {
	str, _ := text.Marshal(0x988f94f380d5b032, capnp.Struct(s))
	return str
}

func (s Buffer_read_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Buffer_read_Params) DecodeFromPtr(p capnp.Ptr) Buffer_read_Params {
	return Buffer_read_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Buffer_read_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Buffer_read_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Buffer_read_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Buffer_read_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Buffer_read_Params) Count() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Buffer_read_Params) SetCount(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

// Buffer_read_Params_List is a list of Buffer_read_Params.
type Buffer_read_Params_List = capnp.StructList[Buffer_read_Params]

// NewBuffer_read_Params creates a new list of Buffer_read_Params.
func NewBuffer_read_Params_List(s *capnp.Segment, sz int32) (Buffer_read_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Buffer_read_Params](l), err
}

// Buffer_read_Params_Future is a wrapper for a Buffer_read_Params promised by a client call.
type Buffer_read_Params_Future struct{ *capnp.Future }

func (f Buffer_read_Params_Future) Struct() (Buffer_read_Params, error) {
	p, err := f.Future.Ptr()
	return Buffer_read_Params(p.Struct()), err
}

type Buffer_read_Results capnp.Struct

// Buffer_read_Results_TypeID is the unique identifier for the type Buffer_read_Results.
const Buffer_read_Results_TypeID = 0xd97c0d57b5fd9e5d

func NewBuffer_read_Results(s *capnp.Segment) (Buffer_read_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Buffer_read_Results(st), err
}

func NewRootBuffer_read_Results(s *capnp.Segment) (Buffer_read_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Buffer_read_Results(st), err
}

func ReadRootBuffer_read_Results(msg *capnp.Message) (Buffer_read_Results, error) {
	root, err := msg.Root()
	return Buffer_read_Results(root.Struct()), err
}

func (s Buffer_read_Results) String() string {
	str, _ := text.Marshal(0xd97c0d57b5fd9e5d, capnp.Struct(s))
	return str
}

func (s Buffer_read_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Buffer_read_Results) DecodeFromPtr(p capnp.Ptr) Buffer_read_Results {
	return Buffer_read_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Buffer_read_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Buffer_read_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Buffer_read_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Buffer_read_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Buffer_read_Results) Output() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Buffer_read_Results) HasOutput() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Buffer_read_Results) SetOutput(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Buffer_read_Results) Status() (Buffer_Status, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Buffer_Status(p.Struct()), err
}

func (s Buffer_read_Results) HasStatus() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Buffer_read_Results) SetStatus(v Buffer_Status) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewStatus sets the status field to a newly
// allocated Buffer_Status struct, preferring placement in s's segment.
func (s Buffer_read_Results) NewStatus() (Buffer_Status, error) {
	ss, err := NewBuffer_Status(capnp.Struct(s).Segment())
	if err != nil {
		return Buffer_Status{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Buffer_read_Results_List is a list of Buffer_read_Results.
type Buffer_read_Results_List = capnp.StructList[Buffer_read_Results]

// NewBuffer_read_Results creates a new list of Buffer_read_Results.
func NewBuffer_read_Results_List(s *capnp.Segment, sz int32) (Buffer_read_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Buffer_read_Results](l), err
}

// Buffer_read_Results_Future is a wrapper for a Buffer_read_Results promised by a client call.
type Buffer_read_Results_Future struct{ *capnp.Future }

func (f Buffer_read_Results_Future) Struct() (Buffer_read_Results, error) {
	p, err := f.Future.Ptr()
	return Buffer_read_Results(p.Struct()), err
}
func (p Buffer_read_Results_Future) Status() Buffer_Status_Future {
	return Buffer_Status_Future{Future: p.Future.Field(1, nil)}
}

type Buffer_flush_Params capnp.Struct

// Buffer_flush_Params_TypeID is the unique identifier for the type Buffer_flush_Params.
const Buffer_flush_Params_TypeID = 0xe6195e5a8613fc66

func NewBuffer_flush_Params(s *capnp.Segment) (Buffer_flush_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Buffer_flush_Params(st), err
}

func NewRootBuffer_flush_Params(s *capnp.Segment) (Buffer_flush_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Buffer_flush_Params(st), err
}

func ReadRootBuffer_flush_Params(msg *capnp.Message) (Buffer_flush_Params, error) {
	root, err := msg.Root()
	return Buffer_flush_Params(root.Struct()), err
}

func (s Buffer_flush_Params) String() string {
	str, _ := text.Marshal(0xe6195e5a8613fc66, capnp.Struct(s))
	return str
}

func (s Buffer_flush_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Buffer_flush_Params) DecodeFromPtr(p capnp.Ptr) Buffer_flush_Params {
	return Buffer_flush_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Buffer_flush_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Buffer_flush_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Buffer_flush_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Buffer_flush_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Buffer_flush_Params_List is a list of Buffer_flush_Params.
type Buffer_flush_Params_List = capnp.StructList[Buffer_flush_Params]

// NewBuffer_flush_Params creates a new list of Buffer_flush_Params.
func NewBuffer_flush_Params_List(s *capnp.Segment, sz int32) (Buffer_flush_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Buffer_flush_Params](l), err
}

// Buffer_flush_Params_Future is a wrapper for a Buffer_flush_Params promised by a client call.
type Buffer_flush_Params_Future struct{ *capnp.Future }

func (f Buffer_flush_Params_Future) Struct() (Buffer_flush_Params, error) {
	p, err := f.Future.Ptr()
	return Buffer_flush_Params(p.Struct()), err
}

type Buffer_flush_Results capnp.Struct

// Buffer_flush_Results_TypeID is the unique identifier for the type Buffer_flush_Results.
const Buffer_flush_Results_TypeID = 0xa71b7c75f8fd8005

func NewBuffer_flush_Results(s *capnp.Segment) (Buffer_flush_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Buffer_flush_Results(st), err
}

func NewRootBuffer_flush_Results(s *capnp.Segment) (Buffer_flush_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Buffer_flush_Results(st), err
}

func ReadRootBuffer_flush_Results(msg *capnp.Message) (Buffer_flush_Results, error) {
	root, err := msg.Root()
	return Buffer_flush_Results(root.Struct()), err
}

func (s Buffer_flush_Results) String() string {
	str, _ := text.Marshal(0xa71b7c75f8fd8005, capnp.Struct(s))
	return str
}

func (s Buffer_flush_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Buffer_flush_Results) DecodeFromPtr(p capnp.Ptr) Buffer_flush_Results {
	return Buffer_flush_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Buffer_flush_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Buffer_flush_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Buffer_flush_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Buffer_flush_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Buffer_flush_Results_List is a list of Buffer_flush_Results.
type Buffer_flush_Results_List = capnp.StructList[Buffer_flush_Results]

// NewBuffer_flush_Results creates a new list of Buffer_flush_Results.
func NewBuffer_flush_Results_List(s *capnp.Segment, sz int32) (Buffer_flush_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Buffer_flush_Results](l), err
}

// Buffer_flush_Results_Future is a wrapper for a Buffer_flush_Results promised by a client call.
type Buffer_flush_Results_Future struct{ *capnp.Future }

func (f Buffer_flush_Results_Future) Struct() (Buffer_flush_Results, error) {
	p, err := f.Future.Ptr()
	return Buffer_flush_Results(p.Struct()), err
}

const schema_ead48f650c32a806 = "x\xda\x8cUQh\x1cU\x14\xbd\xe7\xbd\x99\x9d\xa6\xec" +
	"\xda<'*U\xca\xa2,\xa2\xd5\x84v\xe3\x87\x06t" +
	"\xd7\xea\xd2\xaam\xd8I\x04Mm\xc5I2\xdb,n" +
	"w6\xb3\xb3\xa6B\xc5\x06R\xc5\x0fm\x03\"\xa2 " +
	"U\x10-\x08\xb5)\x15\xb4\xe4\xc7\x92\x1f\xbf\x1a\xb5B" +
	"\x10\xfc\x10\xb5\xb5\xfd\x10\xf1C\x09\xc6\x91\xf7&\xb3;" +
	"\xc9&\xa4_\x09\xfb\xde\x9ew\xce\xb9\xe7\xdc\xdd\x91g" +
	"ymg\xeaJ\x82\x98U\xd4\x13\xc1\x05\xf3\xa7\xfb\xfe" +
	"\x1e\x7fa\x8aD\x17\x88t\x18D\xbdC<\x0b\x82i" +
	"\xf3\x1c!\xc8~~\xf9\xd8_o\x9fx\x97,\x13 " +
	"\xd2\x0c\"s\x92/\x12\xcc\xe3\xea\\?\xb6\xf4O\xe3" +
	"\xe8\x1d\x9f\x900\x97\x8f{?\xe6\x9bAZ\xf0\xce\x87" +
	"\x07\xcf=w-\xf3Yx\x12B\xbf\xc9\x99\x84\x9eV" +
	"_\x1d\xdf\xf6\xf5\xd4\xe2\xa5\xe9s\x0a:x\xb6\xbf2" +
	"\xf7\xd6c\xc7/R\x01\x06'2\xcf\xf2o\xcdY." +
	"\x9f\xfb\x92\x9f!\x045q\x05\x8f\\?s\x81\xc4\xad" +
	"M8K\xeb\x93pC\x9a\x84;\xf9\xfa\x17\x0f~w" +
	"\xf1\xa9Y\x12I\x1e$>\xcd&\x9d\x13\xdf_#\x82" +
	"\xf9\xb2\xf6\x919\xa9\x88\xbf\xa2\xed6O\xcb\xff\x82S" +
	"\xbf|\xb5\xf5\xc0\xcf\xfd\xb3\xa1nE{Z\xdb.i" +
	"7y\xb4\xc3\xbcgNj\xb7\x11\xf5\xbe\xa1\x190\xbb" +
	"u\x89\xd3\xbf073s\xf3\x81\xf9\xb8\xc8[\xf4\xcd" +
	"\x92\xd56]\xb2\xda\xbf\xe7R\xfd\xd4\x88\xb9\x10\xa7\xfd" +
	"\xb0\xae\x0c.\xa8\x0b\x07?X:\xffL\xea\xe8\xc22" +
	"\x02\x93\x17\x1c]\xd9T\xd6'\x08A\xe9_\xf3\xb5\xfd" +
	"\xcfo\xfd-\xe6\xf0\x9c<\xd7\x82\xbbO\x9e\x9f\xef," +
	"\xdet=\xfe\xf8\xe9\x10\xfb\xac\xc2\xbe\x8a\x8e\x9d?\x1a" +
	"\xc6\x1fmZ\xe6\xf5\x19sA\x0a0/\xeb\xbbM$" +
	"\xa4\x94\xf7\xef\xbf\xfa\xc37S\xbf.\xc6\xd1~\xd7\x95" +
	"\xc1\x7f\xea9\xea\x0e\xeacN\xa5\xd23b\xf3Z\xb5" +
	"\xd6\xb7\xcf.W\x86\xdd#=UgbW\xa3Tr" +
	"\xbc\xcc\x80\x93\xae7*~\xdd\xd2\xb8F\xa4\x81H\xa4" +
	"\xfa\x88\xacM\x1cV\x17CnX]\x83h9L\x80" +
	" 4q\x99\xc4\x0d\xc1z<\xc7\x1e\xcd\xe4\x8a\xb6g" +
	"\x1f^\x01\x98m\x01\xa6G\xdcF\xd5G\x071t\xc4" +
	"Px\x0c\xa5Ti\xd4\xc72\x03\x8e\xe2E\xb4\xe6\x9d" +
	"\x09\xaf\xec;\x99\xf0%Z\xef\xa9r\xb5\xd6\xf0\x91\"" +
	"\x86\xd4:\x84\x07}\xdbo\xa0^\x04\xac$\xd7\x92A" +
	"\xa0@\x0a\xb7\x13Yy\x0ek/C\x0a\xff\x05]\xb2" +
	"C\xe2\x89\xbb\x88\xac\xc79\xac\"C\x8a-\x05]`" +
	"Db\x9f|p\x0f\x87\xf54\x03w_\xa4\x84\xe1\xb8" +
	"%J\xa4\x1d\xcfs=$\x89!\xb9Zf\xe1%\xa7" +
	"\xea\xefu\xddZ\x8f=:\xfa\xe8\x88\xefz\x99\x81\x9c" +
	"\xd36\x85]-%\xaf\x1e\x0e\xe7\x06\xd1\xea\xcb\xaa1" +
	" \x1a\xaf1\xec\x1e\x91z4\xae\xc7\x1a\x83he\x08" +
	"1@Lt\x18A\x14\x01\x82\x97G\x11\xd8((E" +
	"{\x8b4{\xe5\x83\xf2\x8c;\x9e\xa5!\xb6\x18\x04\xfa" +
	"r\xca\xd8\xba\xd5\xa9HD;\x05Q\xef\xc4x\x96\x98" +
	"p\x0c\xa0\xd9\x06DA\x16C\xc3\xc4\x84e\x805\xb7" +
	"\x18\xa2\xb6\x89\xc2vb\xe2!\x03\xbc\xd9/D\xabL" +
	"tK\xcc;\x8d\xb4\x8aF\x1e\x81\xfa;\xe8{d\x94" +
	"\xab\x87\xf2\xd8\"\xc3\x99GZ\xa5k\x0d\xc5+\x82\xd5" +
	"\x0c\xdfz\xb5\xa8+}\xe8l\xa9&\xa0\xf3\x06&]" +
	"L\xb7\xb5#>\xe81\xbb:Zq\xd6\x09N\xbce" +
	"\x11CkS\x13\xe8^I0\xc3a\xed`\x10@\x98" +
	"\xdan\xf9\xe1=\x1c\xd6\x03\x0c9\xb7\xe1\xc7\x1a\xb1\xb1" +
	"\x08\xa3\xad\x95\xcb\x8d\x8b.\xac6n\xd0\xf7\xca\xd5C" +
	"k\x89l\xef\xe5j\x89\x88\x1cK+\xcbZ\x19\x8e\x96" +
	"1\xa2\x1f\x13!\x9e\x0c3\x1c\xb9JD\x1bLt\x99" +
	"\xd8Z=\xbb\x91\xb1\xfe\x1f\x00\x00\xff\xff\xe7\xa9\x16\x92"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_ead48f650c32a806,
		Nodes: []uint64{
			0x846071f72bde13bb,
			0x988f94f380d5b032,
			0xa71b7c75f8fd8005,
			0xac24ea5bb35da196,
			0xb391d0fa84c21d71,
			0xbbafeb3e01e71170,
			0xbd4bc3d338b68790,
			0xbd4ee25c19bae4a0,
			0xc385438ec56c4e58,
			0xd15c12b2b2c5d94e,
			0xd91363a073d0485a,
			0xd97c0d57b5fd9e5d,
			0xe6195e5a8613fc66,
			0xeb0e5010d1b59026,
			0xef0707db310901e8,
			0xfae584cad6e82c9b,
		},
		Compressed: true,
	})
}
