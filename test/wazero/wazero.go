// Code generated by MockGen. DO NOT EDIT.
// Source: wazero.go

// Package test_wazero is a generated GoMock package.
package test_wazero

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	api "github.com/tetratelabs/wazero/api"
)

// MockModule is a mock of Module interface.
type MockModule struct {
	ctrl     *gomock.Controller
	recorder *MockModuleMockRecorder
}

// MockModuleMockRecorder is the mock recorder for MockModule.
type MockModuleMockRecorder struct {
	mock *MockModule
}

// NewMockModule creates a new mock instance.
func NewMockModule(ctrl *gomock.Controller) *MockModule {
	mock := &MockModule{ctrl: ctrl}
	mock.recorder = &MockModuleMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockModule) EXPECT() *MockModuleMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockModule) Close(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockModuleMockRecorder) Close(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockModule)(nil).Close), arg0)
}

// CloseWithExitCode mocks base method.
func (m *MockModule) CloseWithExitCode(ctx context.Context, exitCode uint32) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CloseWithExitCode", ctx, exitCode)
	ret0, _ := ret[0].(error)
	return ret0
}

// CloseWithExitCode indicates an expected call of CloseWithExitCode.
func (mr *MockModuleMockRecorder) CloseWithExitCode(ctx, exitCode interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CloseWithExitCode", reflect.TypeOf((*MockModule)(nil).CloseWithExitCode), ctx, exitCode)
}

// ExportedFunction mocks base method.
func (m *MockModule) ExportedFunction(name string) api.Function {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExportedFunction", name)
	ret0, _ := ret[0].(api.Function)
	return ret0
}

// ExportedFunction indicates an expected call of ExportedFunction.
func (mr *MockModuleMockRecorder) ExportedFunction(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExportedFunction", reflect.TypeOf((*MockModule)(nil).ExportedFunction), name)
}

// ExportedFunctionDefinitions mocks base method.
func (m *MockModule) ExportedFunctionDefinitions() map[string]api.FunctionDefinition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExportedFunctionDefinitions")
	ret0, _ := ret[0].(map[string]api.FunctionDefinition)
	return ret0
}

// ExportedFunctionDefinitions indicates an expected call of ExportedFunctionDefinitions.
func (mr *MockModuleMockRecorder) ExportedFunctionDefinitions() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExportedFunctionDefinitions", reflect.TypeOf((*MockModule)(nil).ExportedFunctionDefinitions))
}

// ExportedGlobal mocks base method.
func (m *MockModule) ExportedGlobal(name string) api.Global {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExportedGlobal", name)
	ret0, _ := ret[0].(api.Global)
	return ret0
}

// ExportedGlobal indicates an expected call of ExportedGlobal.
func (mr *MockModuleMockRecorder) ExportedGlobal(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExportedGlobal", reflect.TypeOf((*MockModule)(nil).ExportedGlobal), name)
}

// ExportedMemory mocks base method.
func (m *MockModule) ExportedMemory(name string) api.Memory {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExportedMemory", name)
	ret0, _ := ret[0].(api.Memory)
	return ret0
}

// ExportedMemory indicates an expected call of ExportedMemory.
func (mr *MockModuleMockRecorder) ExportedMemory(name interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExportedMemory", reflect.TypeOf((*MockModule)(nil).ExportedMemory), name)
}

// ExportedMemoryDefinitions mocks base method.
func (m *MockModule) ExportedMemoryDefinitions() map[string]api.MemoryDefinition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExportedMemoryDefinitions")
	ret0, _ := ret[0].(map[string]api.MemoryDefinition)
	return ret0
}

// ExportedMemoryDefinitions indicates an expected call of ExportedMemoryDefinitions.
func (mr *MockModuleMockRecorder) ExportedMemoryDefinitions() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExportedMemoryDefinitions", reflect.TypeOf((*MockModule)(nil).ExportedMemoryDefinitions))
}

// IsClosed mocks base method.
func (m *MockModule) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed.
func (mr *MockModuleMockRecorder) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockModule)(nil).IsClosed))
}

// Memory mocks base method.
func (m *MockModule) Memory() api.Memory {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Memory")
	ret0, _ := ret[0].(api.Memory)
	return ret0
}

// Memory indicates an expected call of Memory.
func (mr *MockModuleMockRecorder) Memory() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Memory", reflect.TypeOf((*MockModule)(nil).Memory))
}

// Name mocks base method.
func (m *MockModule) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockModuleMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockModule)(nil).Name))
}

// String mocks base method.
func (m *MockModule) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String.
func (mr *MockModuleMockRecorder) String() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockModule)(nil).String))
}

// wazeroOnly mocks base method.
func (m *MockModule) wazeroOnly() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "wazeroOnly")
}

// wazeroOnly indicates an expected call of wazeroOnly.
func (mr *MockModuleMockRecorder) wazeroOnly() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "wazeroOnly", reflect.TypeOf((*MockModule)(nil).wazeroOnly))
}

// MockFunction is a mock of Function interface.
type MockFunction struct {
	ctrl     *gomock.Controller
	recorder *MockFunctionMockRecorder
}

// MockFunctionMockRecorder is the mock recorder for MockFunction.
type MockFunctionMockRecorder struct {
	mock *MockFunction
}

// NewMockFunction creates a new mock instance.
func NewMockFunction(ctrl *gomock.Controller) *MockFunction {
	mock := &MockFunction{ctrl: ctrl}
	mock.recorder = &MockFunctionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFunction) EXPECT() *MockFunctionMockRecorder {
	return m.recorder
}

// Call mocks base method.
func (m *MockFunction) Call(ctx context.Context, params ...uint64) ([]uint64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range params {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Call", varargs...)
	ret0, _ := ret[0].([]uint64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Call indicates an expected call of Call.
func (mr *MockFunctionMockRecorder) Call(ctx interface{}, params ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, params...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Call", reflect.TypeOf((*MockFunction)(nil).Call), varargs...)
}

// CallWithStack mocks base method.
func (m *MockFunction) CallWithStack(ctx context.Context, stack []uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CallWithStack", ctx, stack)
	ret0, _ := ret[0].(error)
	return ret0
}

// CallWithStack indicates an expected call of CallWithStack.
func (mr *MockFunctionMockRecorder) CallWithStack(ctx, stack interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CallWithStack", reflect.TypeOf((*MockFunction)(nil).CallWithStack), ctx, stack)
}

// Definition mocks base method.
func (m *MockFunction) Definition() api.FunctionDefinition {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Definition")
	ret0, _ := ret[0].(api.FunctionDefinition)
	return ret0
}

// Definition indicates an expected call of Definition.
func (mr *MockFunctionMockRecorder) Definition() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Definition", reflect.TypeOf((*MockFunction)(nil).Definition))
}

// wazeroOnly mocks base method.
func (m *MockFunction) wazeroOnly() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "wazeroOnly")
}

// wazeroOnly indicates an expected call of wazeroOnly.
func (mr *MockFunctionMockRecorder) wazeroOnly() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "wazeroOnly", reflect.TypeOf((*MockFunction)(nil).wazeroOnly))
}
