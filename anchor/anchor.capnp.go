// Code generated by capnpc-go. DO NOT EDIT.

package anchor

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
)

type Block capnp.Client

// Block_TypeID is the unique identifier for the type Block.
const Block_TypeID = 0xa6a36110b9b24f44

func (c Block) Cid(ctx context.Context, params func(Block_cid_Params) error) (Block_cid_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xa6a36110b9b24f44,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Block",
			MethodName:    "cid",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Block_cid_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Block_cid_Results_Future{Future: ans.Future()}, release

}

func (c Block) RawData(ctx context.Context, params func(Block_rawData_Params) error) (Block_rawData_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xa6a36110b9b24f44,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Block",
			MethodName:    "rawData",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Block_rawData_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Block_rawData_Results_Future{Future: ans.Future()}, release

}

func (c Block) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Block) String() string {
	return "Block(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Block) AddRef() Block {
	return Block(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Block) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Block) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Block) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Block) DecodeFromPtr(p capnp.Ptr) Block {
	return Block(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Block) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Block) IsSame(other Block) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Block) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Block) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Block_Server is a Block with a local implementation.
type Block_Server interface {
	Cid(context.Context, Block_cid) error

	RawData(context.Context, Block_rawData) error
}

// Block_NewServer creates a new Server from an implementation of Block_Server.
func Block_NewServer(s Block_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Block_Methods(nil, s), s, c)
}

// Block_ServerToClient creates a new Client from an implementation of Block_Server.
// The caller is responsible for calling Release on the returned Client.
func Block_ServerToClient(s Block_Server) Block {
	return Block(capnp.NewClient(Block_NewServer(s)))
}

// Block_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Block_Methods(methods []server.Method, s Block_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xa6a36110b9b24f44,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Block",
			MethodName:    "cid",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Cid(ctx, Block_cid{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xa6a36110b9b24f44,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Block",
			MethodName:    "rawData",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.RawData(ctx, Block_rawData{call})
		},
	})

	return methods
}

// Block_cid holds the state for a server call to Block.cid.
// See server.Call for documentation.
type Block_cid struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Block_cid) Args() Block_cid_Params {
	return Block_cid_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Block_cid) AllocResults() (Block_cid_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Block_cid_Results(r), err
}

// Block_rawData holds the state for a server call to Block.rawData.
// See server.Call for documentation.
type Block_rawData struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Block_rawData) Args() Block_rawData_Params {
	return Block_rawData_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Block_rawData) AllocResults() (Block_rawData_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Block_rawData_Results(r), err
}

// Block_List is a list of Block.
type Block_List = capnp.CapList[Block]

// NewBlock creates a new list of Block.
func NewBlock_List(s *capnp.Segment, sz int32) (Block_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Block](l), err
}

type Block_cid_Params capnp.Struct

// Block_cid_Params_TypeID is the unique identifier for the type Block_cid_Params.
const Block_cid_Params_TypeID = 0xc8d028b1f017c0d9

func NewBlock_cid_Params(s *capnp.Segment) (Block_cid_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Block_cid_Params(st), err
}

func NewRootBlock_cid_Params(s *capnp.Segment) (Block_cid_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Block_cid_Params(st), err
}

func ReadRootBlock_cid_Params(msg *capnp.Message) (Block_cid_Params, error) {
	root, err := msg.Root()
	return Block_cid_Params(root.Struct()), err
}

func (s Block_cid_Params) String() string {
	str, _ := text.Marshal(0xc8d028b1f017c0d9, capnp.Struct(s))
	return str
}

func (s Block_cid_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Block_cid_Params) DecodeFromPtr(p capnp.Ptr) Block_cid_Params {
	return Block_cid_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Block_cid_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Block_cid_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Block_cid_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Block_cid_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Block_cid_Params_List is a list of Block_cid_Params.
type Block_cid_Params_List = capnp.StructList[Block_cid_Params]

// NewBlock_cid_Params creates a new list of Block_cid_Params.
func NewBlock_cid_Params_List(s *capnp.Segment, sz int32) (Block_cid_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Block_cid_Params](l), err
}

// Block_cid_Params_Future is a wrapper for a Block_cid_Params promised by a client call.
type Block_cid_Params_Future struct{ *capnp.Future }

func (f Block_cid_Params_Future) Struct() (Block_cid_Params, error) {
	p, err := f.Future.Ptr()
	return Block_cid_Params(p.Struct()), err
}

type Block_cid_Results capnp.Struct

// Block_cid_Results_TypeID is the unique identifier for the type Block_cid_Results.
const Block_cid_Results_TypeID = 0xb92f8f375c469673

func NewBlock_cid_Results(s *capnp.Segment) (Block_cid_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Block_cid_Results(st), err
}

func NewRootBlock_cid_Results(s *capnp.Segment) (Block_cid_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Block_cid_Results(st), err
}

func ReadRootBlock_cid_Results(msg *capnp.Message) (Block_cid_Results, error) {
	root, err := msg.Root()
	return Block_cid_Results(root.Struct()), err
}

func (s Block_cid_Results) String() string {
	str, _ := text.Marshal(0xb92f8f375c469673, capnp.Struct(s))
	return str
}

func (s Block_cid_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Block_cid_Results) DecodeFromPtr(p capnp.Ptr) Block_cid_Results {
	return Block_cid_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Block_cid_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Block_cid_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Block_cid_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Block_cid_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Block_cid_Results) Cid() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Block_cid_Results) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Block_cid_Results) SetCid(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// Block_cid_Results_List is a list of Block_cid_Results.
type Block_cid_Results_List = capnp.StructList[Block_cid_Results]

// NewBlock_cid_Results creates a new list of Block_cid_Results.
func NewBlock_cid_Results_List(s *capnp.Segment, sz int32) (Block_cid_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Block_cid_Results](l), err
}

// Block_cid_Results_Future is a wrapper for a Block_cid_Results promised by a client call.
type Block_cid_Results_Future struct{ *capnp.Future }

func (f Block_cid_Results_Future) Struct() (Block_cid_Results, error) {
	p, err := f.Future.Ptr()
	return Block_cid_Results(p.Struct()), err
}

type Block_rawData_Params capnp.Struct

// Block_rawData_Params_TypeID is the unique identifier for the type Block_rawData_Params.
const Block_rawData_Params_TypeID = 0x92fcf0466de7f964

func NewBlock_rawData_Params(s *capnp.Segment) (Block_rawData_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Block_rawData_Params(st), err
}

func NewRootBlock_rawData_Params(s *capnp.Segment) (Block_rawData_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Block_rawData_Params(st), err
}

func ReadRootBlock_rawData_Params(msg *capnp.Message) (Block_rawData_Params, error) {
	root, err := msg.Root()
	return Block_rawData_Params(root.Struct()), err
}

func (s Block_rawData_Params) String() string {
	str, _ := text.Marshal(0x92fcf0466de7f964, capnp.Struct(s))
	return str
}

func (s Block_rawData_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Block_rawData_Params) DecodeFromPtr(p capnp.Ptr) Block_rawData_Params {
	return Block_rawData_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Block_rawData_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Block_rawData_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Block_rawData_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Block_rawData_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Block_rawData_Params_List is a list of Block_rawData_Params.
type Block_rawData_Params_List = capnp.StructList[Block_rawData_Params]

// NewBlock_rawData_Params creates a new list of Block_rawData_Params.
func NewBlock_rawData_Params_List(s *capnp.Segment, sz int32) (Block_rawData_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Block_rawData_Params](l), err
}

// Block_rawData_Params_Future is a wrapper for a Block_rawData_Params promised by a client call.
type Block_rawData_Params_Future struct{ *capnp.Future }

func (f Block_rawData_Params_Future) Struct() (Block_rawData_Params, error) {
	p, err := f.Future.Ptr()
	return Block_rawData_Params(p.Struct()), err
}

type Block_rawData_Results capnp.Struct

// Block_rawData_Results_TypeID is the unique identifier for the type Block_rawData_Results.
const Block_rawData_Results_TypeID = 0xb308483578d8e6ce

func NewBlock_rawData_Results(s *capnp.Segment) (Block_rawData_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Block_rawData_Results(st), err
}

func NewRootBlock_rawData_Results(s *capnp.Segment) (Block_rawData_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Block_rawData_Results(st), err
}

func ReadRootBlock_rawData_Results(msg *capnp.Message) (Block_rawData_Results, error) {
	root, err := msg.Root()
	return Block_rawData_Results(root.Struct()), err
}

func (s Block_rawData_Results) String() string {
	str, _ := text.Marshal(0xb308483578d8e6ce, capnp.Struct(s))
	return str
}

func (s Block_rawData_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Block_rawData_Results) DecodeFromPtr(p capnp.Ptr) Block_rawData_Results {
	return Block_rawData_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Block_rawData_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Block_rawData_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Block_rawData_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Block_rawData_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Block_rawData_Results) Data() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Block_rawData_Results) HasData() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Block_rawData_Results) SetData(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// Block_rawData_Results_List is a list of Block_rawData_Results.
type Block_rawData_Results_List = capnp.StructList[Block_rawData_Results]

// NewBlock_rawData_Results creates a new list of Block_rawData_Results.
func NewBlock_rawData_Results_List(s *capnp.Segment, sz int32) (Block_rawData_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Block_rawData_Results](l), err
}

// Block_rawData_Results_Future is a wrapper for a Block_rawData_Results promised by a client call.
type Block_rawData_Results_Future struct{ *capnp.Future }

func (f Block_rawData_Results_Future) Struct() (Block_rawData_Results, error) {
	p, err := f.Future.Ptr()
	return Block_rawData_Results(p.Struct()), err
}

type Resolver capnp.Client

// Resolver_TypeID is the unique identifier for the type Resolver.
const Resolver_TypeID = 0x9721c5b150e379b1

func (c Resolver) ResolvePath(ctx context.Context, params func(Resolver_resolvePath_Params) error) (Resolver_resolvePath_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9721c5b150e379b1,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Resolver",
			MethodName:    "resolvePath",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Resolver_resolvePath_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Resolver_resolvePath_Results_Future{Future: ans.Future()}, release

}

func (c Resolver) Tree(ctx context.Context, params func(Resolver_tree_Params) error) (Resolver_tree_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9721c5b150e379b1,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Resolver",
			MethodName:    "tree",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Resolver_tree_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Resolver_tree_Results_Future{Future: ans.Future()}, release

}

func (c Resolver) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Resolver) String() string {
	return "Resolver(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Resolver) AddRef() Resolver {
	return Resolver(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Resolver) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Resolver) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Resolver) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Resolver) DecodeFromPtr(p capnp.Ptr) Resolver {
	return Resolver(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Resolver) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Resolver) IsSame(other Resolver) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Resolver) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Resolver) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Resolver_Server is a Resolver with a local implementation.
type Resolver_Server interface {
	ResolvePath(context.Context, Resolver_resolvePath) error

	Tree(context.Context, Resolver_tree) error
}

// Resolver_NewServer creates a new Server from an implementation of Resolver_Server.
func Resolver_NewServer(s Resolver_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Resolver_Methods(nil, s), s, c)
}

// Resolver_ServerToClient creates a new Client from an implementation of Resolver_Server.
// The caller is responsible for calling Release on the returned Client.
func Resolver_ServerToClient(s Resolver_Server) Resolver {
	return Resolver(capnp.NewClient(Resolver_NewServer(s)))
}

// Resolver_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Resolver_Methods(methods []server.Method, s Resolver_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9721c5b150e379b1,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Resolver",
			MethodName:    "resolvePath",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.ResolvePath(ctx, Resolver_resolvePath{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9721c5b150e379b1,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Resolver",
			MethodName:    "tree",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Tree(ctx, Resolver_tree{call})
		},
	})

	return methods
}

// Resolver_resolvePath holds the state for a server call to Resolver.resolvePath.
// See server.Call for documentation.
type Resolver_resolvePath struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Resolver_resolvePath) Args() Resolver_resolvePath_Params {
	return Resolver_resolvePath_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Resolver_resolvePath) AllocResults() (Resolver_resolvePath_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Resolver_resolvePath_Results(r), err
}

// Resolver_tree holds the state for a server call to Resolver.tree.
// See server.Call for documentation.
type Resolver_tree struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Resolver_tree) Args() Resolver_tree_Params {
	return Resolver_tree_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Resolver_tree) AllocResults() (Resolver_tree_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Resolver_tree_Results(r), err
}

// Resolver_List is a list of Resolver.
type Resolver_List = capnp.CapList[Resolver]

// NewResolver creates a new list of Resolver.
func NewResolver_List(s *capnp.Segment, sz int32) (Resolver_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Resolver](l), err
}

type Resolver_resolvePath_Params capnp.Struct

// Resolver_resolvePath_Params_TypeID is the unique identifier for the type Resolver_resolvePath_Params.
const Resolver_resolvePath_Params_TypeID = 0xf98ea56e50898a7f

func NewResolver_resolvePath_Params(s *capnp.Segment) (Resolver_resolvePath_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Resolver_resolvePath_Params(st), err
}

func NewRootResolver_resolvePath_Params(s *capnp.Segment) (Resolver_resolvePath_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Resolver_resolvePath_Params(st), err
}

func ReadRootResolver_resolvePath_Params(msg *capnp.Message) (Resolver_resolvePath_Params, error) {
	root, err := msg.Root()
	return Resolver_resolvePath_Params(root.Struct()), err
}

func (s Resolver_resolvePath_Params) String() string {
	str, _ := text.Marshal(0xf98ea56e50898a7f, capnp.Struct(s))
	return str
}

func (s Resolver_resolvePath_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Resolver_resolvePath_Params) DecodeFromPtr(p capnp.Ptr) Resolver_resolvePath_Params {
	return Resolver_resolvePath_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Resolver_resolvePath_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Resolver_resolvePath_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Resolver_resolvePath_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Resolver_resolvePath_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Resolver_resolvePath_Params) Path() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s Resolver_resolvePath_Params) HasPath() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Resolver_resolvePath_Params) SetPath(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewPath sets the path field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Resolver_resolvePath_Params) NewPath(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Resolver_resolvePath_Params_List is a list of Resolver_resolvePath_Params.
type Resolver_resolvePath_Params_List = capnp.StructList[Resolver_resolvePath_Params]

// NewResolver_resolvePath_Params creates a new list of Resolver_resolvePath_Params.
func NewResolver_resolvePath_Params_List(s *capnp.Segment, sz int32) (Resolver_resolvePath_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Resolver_resolvePath_Params](l), err
}

// Resolver_resolvePath_Params_Future is a wrapper for a Resolver_resolvePath_Params promised by a client call.
type Resolver_resolvePath_Params_Future struct{ *capnp.Future }

func (f Resolver_resolvePath_Params_Future) Struct() (Resolver_resolvePath_Params, error) {
	p, err := f.Future.Ptr()
	return Resolver_resolvePath_Params(p.Struct()), err
}

type Resolver_resolvePath_Results capnp.Struct

// Resolver_resolvePath_Results_TypeID is the unique identifier for the type Resolver_resolvePath_Results.
const Resolver_resolvePath_Results_TypeID = 0xa535d74d6368e259

func NewResolver_resolvePath_Results(s *capnp.Segment) (Resolver_resolvePath_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Resolver_resolvePath_Results(st), err
}

func NewRootResolver_resolvePath_Results(s *capnp.Segment) (Resolver_resolvePath_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Resolver_resolvePath_Results(st), err
}

func ReadRootResolver_resolvePath_Results(msg *capnp.Message) (Resolver_resolvePath_Results, error) {
	root, err := msg.Root()
	return Resolver_resolvePath_Results(root.Struct()), err
}

func (s Resolver_resolvePath_Results) String() string {
	str, _ := text.Marshal(0xa535d74d6368e259, capnp.Struct(s))
	return str
}

func (s Resolver_resolvePath_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Resolver_resolvePath_Results) DecodeFromPtr(p capnp.Ptr) Resolver_resolvePath_Results {
	return Resolver_resolvePath_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Resolver_resolvePath_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Resolver_resolvePath_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Resolver_resolvePath_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Resolver_resolvePath_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Resolver_resolvePath_Results) Node() Node {
	p, _ := capnp.Struct(s).Ptr(0)
	return Node(p.Interface().Client())
}

func (s Resolver_resolvePath_Results) HasNode() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Resolver_resolvePath_Results) SetNode(v Node) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s Resolver_resolvePath_Results) RemainingPath() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s Resolver_resolvePath_Results) HasRemainingPath() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Resolver_resolvePath_Results) SetRemainingPath(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewRemainingPath sets the remainingPath field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Resolver_resolvePath_Results) NewRemainingPath(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Resolver_resolvePath_Results_List is a list of Resolver_resolvePath_Results.
type Resolver_resolvePath_Results_List = capnp.StructList[Resolver_resolvePath_Results]

// NewResolver_resolvePath_Results creates a new list of Resolver_resolvePath_Results.
func NewResolver_resolvePath_Results_List(s *capnp.Segment, sz int32) (Resolver_resolvePath_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Resolver_resolvePath_Results](l), err
}

// Resolver_resolvePath_Results_Future is a wrapper for a Resolver_resolvePath_Results promised by a client call.
type Resolver_resolvePath_Results_Future struct{ *capnp.Future }

func (f Resolver_resolvePath_Results_Future) Struct() (Resolver_resolvePath_Results, error) {
	p, err := f.Future.Ptr()
	return Resolver_resolvePath_Results(p.Struct()), err
}
func (p Resolver_resolvePath_Results_Future) Node() Node {
	return Node(p.Future.Field(0, nil).Client())
}

type Resolver_tree_Params capnp.Struct

// Resolver_tree_Params_TypeID is the unique identifier for the type Resolver_tree_Params.
const Resolver_tree_Params_TypeID = 0x8fc9e8ffd96b2fab

func NewResolver_tree_Params(s *capnp.Segment) (Resolver_tree_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Resolver_tree_Params(st), err
}

func NewRootResolver_tree_Params(s *capnp.Segment) (Resolver_tree_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Resolver_tree_Params(st), err
}

func ReadRootResolver_tree_Params(msg *capnp.Message) (Resolver_tree_Params, error) {
	root, err := msg.Root()
	return Resolver_tree_Params(root.Struct()), err
}

func (s Resolver_tree_Params) String() string {
	str, _ := text.Marshal(0x8fc9e8ffd96b2fab, capnp.Struct(s))
	return str
}

func (s Resolver_tree_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Resolver_tree_Params) DecodeFromPtr(p capnp.Ptr) Resolver_tree_Params {
	return Resolver_tree_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Resolver_tree_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Resolver_tree_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Resolver_tree_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Resolver_tree_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Resolver_tree_Params) Path() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Resolver_tree_Params) HasPath() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Resolver_tree_Params) PathBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Resolver_tree_Params) SetPath(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Resolver_tree_Params) Depth() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s Resolver_tree_Params) SetDepth(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

// Resolver_tree_Params_List is a list of Resolver_tree_Params.
type Resolver_tree_Params_List = capnp.StructList[Resolver_tree_Params]

// NewResolver_tree_Params creates a new list of Resolver_tree_Params.
func NewResolver_tree_Params_List(s *capnp.Segment, sz int32) (Resolver_tree_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Resolver_tree_Params](l), err
}

// Resolver_tree_Params_Future is a wrapper for a Resolver_tree_Params promised by a client call.
type Resolver_tree_Params_Future struct{ *capnp.Future }

func (f Resolver_tree_Params_Future) Struct() (Resolver_tree_Params, error) {
	p, err := f.Future.Ptr()
	return Resolver_tree_Params(p.Struct()), err
}

type Resolver_tree_Results capnp.Struct

// Resolver_tree_Results_TypeID is the unique identifier for the type Resolver_tree_Results.
const Resolver_tree_Results_TypeID = 0xc83b2e2c52631a5c

func NewResolver_tree_Results(s *capnp.Segment) (Resolver_tree_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Resolver_tree_Results(st), err
}

func NewRootResolver_tree_Results(s *capnp.Segment) (Resolver_tree_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Resolver_tree_Results(st), err
}

func ReadRootResolver_tree_Results(msg *capnp.Message) (Resolver_tree_Results, error) {
	root, err := msg.Root()
	return Resolver_tree_Results(root.Struct()), err
}

func (s Resolver_tree_Results) String() string {
	str, _ := text.Marshal(0xc83b2e2c52631a5c, capnp.Struct(s))
	return str
}

func (s Resolver_tree_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Resolver_tree_Results) DecodeFromPtr(p capnp.Ptr) Resolver_tree_Results {
	return Resolver_tree_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Resolver_tree_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Resolver_tree_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Resolver_tree_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Resolver_tree_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Resolver_tree_Results) Paths() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s Resolver_tree_Results) HasPaths() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Resolver_tree_Results) SetPaths(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewPaths sets the paths field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Resolver_tree_Results) NewPaths(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Resolver_tree_Results_List is a list of Resolver_tree_Results.
type Resolver_tree_Results_List = capnp.StructList[Resolver_tree_Results]

// NewResolver_tree_Results creates a new list of Resolver_tree_Results.
func NewResolver_tree_Results_List(s *capnp.Segment, sz int32) (Resolver_tree_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Resolver_tree_Results](l), err
}

// Resolver_tree_Results_Future is a wrapper for a Resolver_tree_Results promised by a client call.
type Resolver_tree_Results_Future struct{ *capnp.Future }

func (f Resolver_tree_Results_Future) Struct() (Resolver_tree_Results, error) {
	p, err := f.Future.Ptr()
	return Resolver_tree_Results(p.Struct()), err
}

type Node capnp.Client

// Node_TypeID is the unique identifier for the type Node.
const Node_TypeID = 0xe4d7f77ef9c643ff

func (c Node) ResolveLink(ctx context.Context, params func(Node_resolveLink_Params) error) (Node_resolveLink_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe4d7f77ef9c643ff,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Node",
			MethodName:    "resolveLink",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Node_resolveLink_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Node_resolveLink_Results_Future{Future: ans.Future()}, release

}

func (c Node) Copy(ctx context.Context, params func(Node_copy_Params) error) (Node_copy_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe4d7f77ef9c643ff,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Node",
			MethodName:    "copy",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Node_copy_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Node_copy_Results_Future{Future: ans.Future()}, release

}

func (c Node) Links(ctx context.Context, params func(Node_links_Params) error) (Node_links_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe4d7f77ef9c643ff,
			MethodID:      2,
			InterfaceName: "anchor.capnp:Node",
			MethodName:    "links",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Node_links_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Node_links_Results_Future{Future: ans.Future()}, release

}

func (c Node) Stat(ctx context.Context, params func(Node_stat_Params) error) (Node_stat_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe4d7f77ef9c643ff,
			MethodID:      3,
			InterfaceName: "anchor.capnp:Node",
			MethodName:    "stat",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Node_stat_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Node_stat_Results_Future{Future: ans.Future()}, release

}

func (c Node) Size(ctx context.Context, params func(Node_size_Params) error) (Node_size_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xe4d7f77ef9c643ff,
			MethodID:      4,
			InterfaceName: "anchor.capnp:Node",
			MethodName:    "size",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Node_size_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Node_size_Results_Future{Future: ans.Future()}, release

}

func (c Node) Cid(ctx context.Context, params func(Block_cid_Params) error) (Block_cid_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xa6a36110b9b24f44,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Block",
			MethodName:    "cid",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Block_cid_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Block_cid_Results_Future{Future: ans.Future()}, release

}

func (c Node) RawData(ctx context.Context, params func(Block_rawData_Params) error) (Block_rawData_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xa6a36110b9b24f44,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Block",
			MethodName:    "rawData",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Block_rawData_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Block_rawData_Results_Future{Future: ans.Future()}, release

}

func (c Node) ResolvePath(ctx context.Context, params func(Resolver_resolvePath_Params) error) (Resolver_resolvePath_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9721c5b150e379b1,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Resolver",
			MethodName:    "resolvePath",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Resolver_resolvePath_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Resolver_resolvePath_Results_Future{Future: ans.Future()}, release

}

func (c Node) Tree(ctx context.Context, params func(Resolver_tree_Params) error) (Resolver_tree_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x9721c5b150e379b1,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Resolver",
			MethodName:    "tree",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 8, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Resolver_tree_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Resolver_tree_Results_Future{Future: ans.Future()}, release

}

func (c Node) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Node) String() string {
	return "Node(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Node) AddRef() Node {
	return Node(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Node) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Node) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Node) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Node) DecodeFromPtr(p capnp.Ptr) Node {
	return Node(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Node) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Node) IsSame(other Node) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Node) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Node) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Node_Server is a Node with a local implementation.
type Node_Server interface {
	ResolveLink(context.Context, Node_resolveLink) error

	Copy(context.Context, Node_copy) error

	Links(context.Context, Node_links) error

	Stat(context.Context, Node_stat) error

	Size(context.Context, Node_size) error

	Cid(context.Context, Block_cid) error

	RawData(context.Context, Block_rawData) error

	ResolvePath(context.Context, Resolver_resolvePath) error

	Tree(context.Context, Resolver_tree) error
}

// Node_NewServer creates a new Server from an implementation of Node_Server.
func Node_NewServer(s Node_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Node_Methods(nil, s), s, c)
}

// Node_ServerToClient creates a new Client from an implementation of Node_Server.
// The caller is responsible for calling Release on the returned Client.
func Node_ServerToClient(s Node_Server) Node {
	return Node(capnp.NewClient(Node_NewServer(s)))
}

// Node_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Node_Methods(methods []server.Method, s Node_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 9)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe4d7f77ef9c643ff,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Node",
			MethodName:    "resolveLink",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.ResolveLink(ctx, Node_resolveLink{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe4d7f77ef9c643ff,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Node",
			MethodName:    "copy",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Copy(ctx, Node_copy{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe4d7f77ef9c643ff,
			MethodID:      2,
			InterfaceName: "anchor.capnp:Node",
			MethodName:    "links",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Links(ctx, Node_links{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe4d7f77ef9c643ff,
			MethodID:      3,
			InterfaceName: "anchor.capnp:Node",
			MethodName:    "stat",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Stat(ctx, Node_stat{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xe4d7f77ef9c643ff,
			MethodID:      4,
			InterfaceName: "anchor.capnp:Node",
			MethodName:    "size",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Size(ctx, Node_size{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xa6a36110b9b24f44,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Block",
			MethodName:    "cid",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Cid(ctx, Block_cid{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xa6a36110b9b24f44,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Block",
			MethodName:    "rawData",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.RawData(ctx, Block_rawData{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9721c5b150e379b1,
			MethodID:      0,
			InterfaceName: "anchor.capnp:Resolver",
			MethodName:    "resolvePath",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.ResolvePath(ctx, Resolver_resolvePath{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x9721c5b150e379b1,
			MethodID:      1,
			InterfaceName: "anchor.capnp:Resolver",
			MethodName:    "tree",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Tree(ctx, Resolver_tree{call})
		},
	})

	return methods
}

// Node_resolveLink holds the state for a server call to Node.resolveLink.
// See server.Call for documentation.
type Node_resolveLink struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Node_resolveLink) Args() Node_resolveLink_Params {
	return Node_resolveLink_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Node_resolveLink) AllocResults() (Node_resolveLink_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Node_resolveLink_Results(r), err
}

// Node_copy holds the state for a server call to Node.copy.
// See server.Call for documentation.
type Node_copy struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Node_copy) Args() Node_copy_Params {
	return Node_copy_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Node_copy) AllocResults() (Node_copy_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node_copy_Results(r), err
}

// Node_links holds the state for a server call to Node.links.
// See server.Call for documentation.
type Node_links struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Node_links) Args() Node_links_Params {
	return Node_links_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Node_links) AllocResults() (Node_links_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node_links_Results(r), err
}

// Node_stat holds the state for a server call to Node.stat.
// See server.Call for documentation.
type Node_stat struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Node_stat) Args() Node_stat_Params {
	return Node_stat_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Node_stat) AllocResults() (Node_stat_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node_stat_Results(r), err
}

// Node_size holds the state for a server call to Node.size.
// See server.Call for documentation.
type Node_size struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Node_size) Args() Node_size_Params {
	return Node_size_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Node_size) AllocResults() (Node_size_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Node_size_Results(r), err
}

// Node_List is a list of Node.
type Node_List = capnp.CapList[Node]

// NewNode creates a new list of Node.
func NewNode_List(s *capnp.Segment, sz int32) (Node_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Node](l), err
}

type Node_resolveLink_Params capnp.Struct

// Node_resolveLink_Params_TypeID is the unique identifier for the type Node_resolveLink_Params.
const Node_resolveLink_Params_TypeID = 0xd4cdf6771f945f40

func NewNode_resolveLink_Params(s *capnp.Segment) (Node_resolveLink_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node_resolveLink_Params(st), err
}

func NewRootNode_resolveLink_Params(s *capnp.Segment) (Node_resolveLink_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node_resolveLink_Params(st), err
}

func ReadRootNode_resolveLink_Params(msg *capnp.Message) (Node_resolveLink_Params, error) {
	root, err := msg.Root()
	return Node_resolveLink_Params(root.Struct()), err
}

func (s Node_resolveLink_Params) String() string {
	str, _ := text.Marshal(0xd4cdf6771f945f40, capnp.Struct(s))
	return str
}

func (s Node_resolveLink_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node_resolveLink_Params) DecodeFromPtr(p capnp.Ptr) Node_resolveLink_Params {
	return Node_resolveLink_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node_resolveLink_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node_resolveLink_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node_resolveLink_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node_resolveLink_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Node_resolveLink_Params) Path() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s Node_resolveLink_Params) HasPath() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Node_resolveLink_Params) SetPath(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewPath sets the path field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Node_resolveLink_Params) NewPath(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Node_resolveLink_Params_List is a list of Node_resolveLink_Params.
type Node_resolveLink_Params_List = capnp.StructList[Node_resolveLink_Params]

// NewNode_resolveLink_Params creates a new list of Node_resolveLink_Params.
func NewNode_resolveLink_Params_List(s *capnp.Segment, sz int32) (Node_resolveLink_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Node_resolveLink_Params](l), err
}

// Node_resolveLink_Params_Future is a wrapper for a Node_resolveLink_Params promised by a client call.
type Node_resolveLink_Params_Future struct{ *capnp.Future }

func (f Node_resolveLink_Params_Future) Struct() (Node_resolveLink_Params, error) {
	p, err := f.Future.Ptr()
	return Node_resolveLink_Params(p.Struct()), err
}

type Node_resolveLink_Results capnp.Struct

// Node_resolveLink_Results_TypeID is the unique identifier for the type Node_resolveLink_Results.
const Node_resolveLink_Results_TypeID = 0xf1c551b3944772d4

func NewNode_resolveLink_Results(s *capnp.Segment) (Node_resolveLink_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Node_resolveLink_Results(st), err
}

func NewRootNode_resolveLink_Results(s *capnp.Segment) (Node_resolveLink_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Node_resolveLink_Results(st), err
}

func ReadRootNode_resolveLink_Results(msg *capnp.Message) (Node_resolveLink_Results, error) {
	root, err := msg.Root()
	return Node_resolveLink_Results(root.Struct()), err
}

func (s Node_resolveLink_Results) String() string {
	str, _ := text.Marshal(0xf1c551b3944772d4, capnp.Struct(s))
	return str
}

func (s Node_resolveLink_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node_resolveLink_Results) DecodeFromPtr(p capnp.Ptr) Node_resolveLink_Results {
	return Node_resolveLink_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node_resolveLink_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node_resolveLink_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node_resolveLink_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node_resolveLink_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Node_resolveLink_Results) Link() (Link, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Link(p.Struct()), err
}

func (s Node_resolveLink_Results) HasLink() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Node_resolveLink_Results) SetLink(v Link) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewLink sets the link field to a newly
// allocated Link struct, preferring placement in s's segment.
func (s Node_resolveLink_Results) NewLink() (Link, error) {
	ss, err := NewLink(capnp.Struct(s).Segment())
	if err != nil {
		return Link{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Node_resolveLink_Results) RemainingPath() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s Node_resolveLink_Results) HasRemainingPath() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Node_resolveLink_Results) SetRemainingPath(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewRemainingPath sets the remainingPath field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Node_resolveLink_Results) NewRemainingPath(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// Node_resolveLink_Results_List is a list of Node_resolveLink_Results.
type Node_resolveLink_Results_List = capnp.StructList[Node_resolveLink_Results]

// NewNode_resolveLink_Results creates a new list of Node_resolveLink_Results.
func NewNode_resolveLink_Results_List(s *capnp.Segment, sz int32) (Node_resolveLink_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Node_resolveLink_Results](l), err
}

// Node_resolveLink_Results_Future is a wrapper for a Node_resolveLink_Results promised by a client call.
type Node_resolveLink_Results_Future struct{ *capnp.Future }

func (f Node_resolveLink_Results_Future) Struct() (Node_resolveLink_Results, error) {
	p, err := f.Future.Ptr()
	return Node_resolveLink_Results(p.Struct()), err
}
func (p Node_resolveLink_Results_Future) Link() Link_Future {
	return Link_Future{Future: p.Future.Field(0, nil)}
}

type Node_copy_Params capnp.Struct

// Node_copy_Params_TypeID is the unique identifier for the type Node_copy_Params.
const Node_copy_Params_TypeID = 0x91d12b7eef773258

func NewNode_copy_Params(s *capnp.Segment) (Node_copy_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Node_copy_Params(st), err
}

func NewRootNode_copy_Params(s *capnp.Segment) (Node_copy_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Node_copy_Params(st), err
}

func ReadRootNode_copy_Params(msg *capnp.Message) (Node_copy_Params, error) {
	root, err := msg.Root()
	return Node_copy_Params(root.Struct()), err
}

func (s Node_copy_Params) String() string {
	str, _ := text.Marshal(0x91d12b7eef773258, capnp.Struct(s))
	return str
}

func (s Node_copy_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node_copy_Params) DecodeFromPtr(p capnp.Ptr) Node_copy_Params {
	return Node_copy_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node_copy_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node_copy_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node_copy_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node_copy_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Node_copy_Params_List is a list of Node_copy_Params.
type Node_copy_Params_List = capnp.StructList[Node_copy_Params]

// NewNode_copy_Params creates a new list of Node_copy_Params.
func NewNode_copy_Params_List(s *capnp.Segment, sz int32) (Node_copy_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Node_copy_Params](l), err
}

// Node_copy_Params_Future is a wrapper for a Node_copy_Params promised by a client call.
type Node_copy_Params_Future struct{ *capnp.Future }

func (f Node_copy_Params_Future) Struct() (Node_copy_Params, error) {
	p, err := f.Future.Ptr()
	return Node_copy_Params(p.Struct()), err
}

type Node_copy_Results capnp.Struct

// Node_copy_Results_TypeID is the unique identifier for the type Node_copy_Results.
const Node_copy_Results_TypeID = 0xa76a4e4bd01b79e3

func NewNode_copy_Results(s *capnp.Segment) (Node_copy_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node_copy_Results(st), err
}

func NewRootNode_copy_Results(s *capnp.Segment) (Node_copy_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node_copy_Results(st), err
}

func ReadRootNode_copy_Results(msg *capnp.Message) (Node_copy_Results, error) {
	root, err := msg.Root()
	return Node_copy_Results(root.Struct()), err
}

func (s Node_copy_Results) String() string {
	str, _ := text.Marshal(0xa76a4e4bd01b79e3, capnp.Struct(s))
	return str
}

func (s Node_copy_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node_copy_Results) DecodeFromPtr(p capnp.Ptr) Node_copy_Results {
	return Node_copy_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node_copy_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node_copy_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node_copy_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node_copy_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Node_copy_Results) Node() Node {
	p, _ := capnp.Struct(s).Ptr(0)
	return Node(p.Interface().Client())
}

func (s Node_copy_Results) HasNode() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Node_copy_Results) SetNode(v Node) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Node_copy_Results_List is a list of Node_copy_Results.
type Node_copy_Results_List = capnp.StructList[Node_copy_Results]

// NewNode_copy_Results creates a new list of Node_copy_Results.
func NewNode_copy_Results_List(s *capnp.Segment, sz int32) (Node_copy_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Node_copy_Results](l), err
}

// Node_copy_Results_Future is a wrapper for a Node_copy_Results promised by a client call.
type Node_copy_Results_Future struct{ *capnp.Future }

func (f Node_copy_Results_Future) Struct() (Node_copy_Results, error) {
	p, err := f.Future.Ptr()
	return Node_copy_Results(p.Struct()), err
}
func (p Node_copy_Results_Future) Node() Node {
	return Node(p.Future.Field(0, nil).Client())
}

type Node_links_Params capnp.Struct

// Node_links_Params_TypeID is the unique identifier for the type Node_links_Params.
const Node_links_Params_TypeID = 0xc2eeea50e23c216d

func NewNode_links_Params(s *capnp.Segment) (Node_links_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Node_links_Params(st), err
}

func NewRootNode_links_Params(s *capnp.Segment) (Node_links_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Node_links_Params(st), err
}

func ReadRootNode_links_Params(msg *capnp.Message) (Node_links_Params, error) {
	root, err := msg.Root()
	return Node_links_Params(root.Struct()), err
}

func (s Node_links_Params) String() string {
	str, _ := text.Marshal(0xc2eeea50e23c216d, capnp.Struct(s))
	return str
}

func (s Node_links_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node_links_Params) DecodeFromPtr(p capnp.Ptr) Node_links_Params {
	return Node_links_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node_links_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node_links_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node_links_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node_links_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Node_links_Params_List is a list of Node_links_Params.
type Node_links_Params_List = capnp.StructList[Node_links_Params]

// NewNode_links_Params creates a new list of Node_links_Params.
func NewNode_links_Params_List(s *capnp.Segment, sz int32) (Node_links_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Node_links_Params](l), err
}

// Node_links_Params_Future is a wrapper for a Node_links_Params promised by a client call.
type Node_links_Params_Future struct{ *capnp.Future }

func (f Node_links_Params_Future) Struct() (Node_links_Params, error) {
	p, err := f.Future.Ptr()
	return Node_links_Params(p.Struct()), err
}

type Node_links_Results capnp.Struct

// Node_links_Results_TypeID is the unique identifier for the type Node_links_Results.
const Node_links_Results_TypeID = 0xd53a7218fd8d2c4f

func NewNode_links_Results(s *capnp.Segment) (Node_links_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node_links_Results(st), err
}

func NewRootNode_links_Results(s *capnp.Segment) (Node_links_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node_links_Results(st), err
}

func ReadRootNode_links_Results(msg *capnp.Message) (Node_links_Results, error) {
	root, err := msg.Root()
	return Node_links_Results(root.Struct()), err
}

func (s Node_links_Results) String() string {
	str, _ := text.Marshal(0xd53a7218fd8d2c4f, capnp.Struct(s))
	return str
}

func (s Node_links_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node_links_Results) DecodeFromPtr(p capnp.Ptr) Node_links_Results {
	return Node_links_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node_links_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node_links_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node_links_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node_links_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Node_links_Results) Links() (Link_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Link_List(p.List()), err
}

func (s Node_links_Results) HasLinks() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Node_links_Results) SetLinks(v Link_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLinks sets the links field to a newly
// allocated Link_List, preferring placement in s's segment.
func (s Node_links_Results) NewLinks(n int32) (Link_List, error) {
	l, err := NewLink_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Link_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Node_links_Results_List is a list of Node_links_Results.
type Node_links_Results_List = capnp.StructList[Node_links_Results]

// NewNode_links_Results creates a new list of Node_links_Results.
func NewNode_links_Results_List(s *capnp.Segment, sz int32) (Node_links_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Node_links_Results](l), err
}

// Node_links_Results_Future is a wrapper for a Node_links_Results promised by a client call.
type Node_links_Results_Future struct{ *capnp.Future }

func (f Node_links_Results_Future) Struct() (Node_links_Results, error) {
	p, err := f.Future.Ptr()
	return Node_links_Results(p.Struct()), err
}

type Node_stat_Params capnp.Struct

// Node_stat_Params_TypeID is the unique identifier for the type Node_stat_Params.
const Node_stat_Params_TypeID = 0xb651cf8910cf7161

func NewNode_stat_Params(s *capnp.Segment) (Node_stat_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Node_stat_Params(st), err
}

func NewRootNode_stat_Params(s *capnp.Segment) (Node_stat_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Node_stat_Params(st), err
}

func ReadRootNode_stat_Params(msg *capnp.Message) (Node_stat_Params, error) {
	root, err := msg.Root()
	return Node_stat_Params(root.Struct()), err
}

func (s Node_stat_Params) String() string {
	str, _ := text.Marshal(0xb651cf8910cf7161, capnp.Struct(s))
	return str
}

func (s Node_stat_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node_stat_Params) DecodeFromPtr(p capnp.Ptr) Node_stat_Params {
	return Node_stat_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node_stat_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node_stat_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node_stat_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node_stat_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Node_stat_Params_List is a list of Node_stat_Params.
type Node_stat_Params_List = capnp.StructList[Node_stat_Params]

// NewNode_stat_Params creates a new list of Node_stat_Params.
func NewNode_stat_Params_List(s *capnp.Segment, sz int32) (Node_stat_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Node_stat_Params](l), err
}

// Node_stat_Params_Future is a wrapper for a Node_stat_Params promised by a client call.
type Node_stat_Params_Future struct{ *capnp.Future }

func (f Node_stat_Params_Future) Struct() (Node_stat_Params, error) {
	p, err := f.Future.Ptr()
	return Node_stat_Params(p.Struct()), err
}

type Node_stat_Results capnp.Struct

// Node_stat_Results_TypeID is the unique identifier for the type Node_stat_Results.
const Node_stat_Results_TypeID = 0xdb93bc45b5cd7994

func NewNode_stat_Results(s *capnp.Segment) (Node_stat_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node_stat_Results(st), err
}

func NewRootNode_stat_Results(s *capnp.Segment) (Node_stat_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Node_stat_Results(st), err
}

func ReadRootNode_stat_Results(msg *capnp.Message) (Node_stat_Results, error) {
	root, err := msg.Root()
	return Node_stat_Results(root.Struct()), err
}

func (s Node_stat_Results) String() string {
	str, _ := text.Marshal(0xdb93bc45b5cd7994, capnp.Struct(s))
	return str
}

func (s Node_stat_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node_stat_Results) DecodeFromPtr(p capnp.Ptr) Node_stat_Results {
	return Node_stat_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node_stat_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node_stat_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node_stat_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node_stat_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Node_stat_Results) Stat() (NodeStat, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return NodeStat(p.Struct()), err
}

func (s Node_stat_Results) HasStat() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Node_stat_Results) SetStat(v NodeStat) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewStat sets the stat field to a newly
// allocated NodeStat struct, preferring placement in s's segment.
func (s Node_stat_Results) NewStat() (NodeStat, error) {
	ss, err := NewNodeStat(capnp.Struct(s).Segment())
	if err != nil {
		return NodeStat{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Node_stat_Results_List is a list of Node_stat_Results.
type Node_stat_Results_List = capnp.StructList[Node_stat_Results]

// NewNode_stat_Results creates a new list of Node_stat_Results.
func NewNode_stat_Results_List(s *capnp.Segment, sz int32) (Node_stat_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Node_stat_Results](l), err
}

// Node_stat_Results_Future is a wrapper for a Node_stat_Results promised by a client call.
type Node_stat_Results_Future struct{ *capnp.Future }

func (f Node_stat_Results_Future) Struct() (Node_stat_Results, error) {
	p, err := f.Future.Ptr()
	return Node_stat_Results(p.Struct()), err
}
func (p Node_stat_Results_Future) Stat() NodeStat_Future {
	return NodeStat_Future{Future: p.Future.Field(0, nil)}
}

type Node_size_Params capnp.Struct

// Node_size_Params_TypeID is the unique identifier for the type Node_size_Params.
const Node_size_Params_TypeID = 0xed3e9cf04e7aa3c3

func NewNode_size_Params(s *capnp.Segment) (Node_size_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Node_size_Params(st), err
}

func NewRootNode_size_Params(s *capnp.Segment) (Node_size_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Node_size_Params(st), err
}

func ReadRootNode_size_Params(msg *capnp.Message) (Node_size_Params, error) {
	root, err := msg.Root()
	return Node_size_Params(root.Struct()), err
}

func (s Node_size_Params) String() string {
	str, _ := text.Marshal(0xed3e9cf04e7aa3c3, capnp.Struct(s))
	return str
}

func (s Node_size_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node_size_Params) DecodeFromPtr(p capnp.Ptr) Node_size_Params {
	return Node_size_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node_size_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node_size_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node_size_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node_size_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Node_size_Params_List is a list of Node_size_Params.
type Node_size_Params_List = capnp.StructList[Node_size_Params]

// NewNode_size_Params creates a new list of Node_size_Params.
func NewNode_size_Params_List(s *capnp.Segment, sz int32) (Node_size_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Node_size_Params](l), err
}

// Node_size_Params_Future is a wrapper for a Node_size_Params promised by a client call.
type Node_size_Params_Future struct{ *capnp.Future }

func (f Node_size_Params_Future) Struct() (Node_size_Params, error) {
	p, err := f.Future.Ptr()
	return Node_size_Params(p.Struct()), err
}

type Node_size_Results capnp.Struct

// Node_size_Results_TypeID is the unique identifier for the type Node_size_Results.
const Node_size_Results_TypeID = 0xccebda0d17fec18a

func NewNode_size_Results(s *capnp.Segment) (Node_size_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Node_size_Results(st), err
}

func NewRootNode_size_Results(s *capnp.Segment) (Node_size_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Node_size_Results(st), err
}

func ReadRootNode_size_Results(msg *capnp.Message) (Node_size_Results, error) {
	root, err := msg.Root()
	return Node_size_Results(root.Struct()), err
}

func (s Node_size_Results) String() string {
	str, _ := text.Marshal(0xccebda0d17fec18a, capnp.Struct(s))
	return str
}

func (s Node_size_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Node_size_Results) DecodeFromPtr(p capnp.Ptr) Node_size_Results {
	return Node_size_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Node_size_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Node_size_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Node_size_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Node_size_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Node_size_Results) Size() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Node_size_Results) SetSize(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

// Node_size_Results_List is a list of Node_size_Results.
type Node_size_Results_List = capnp.StructList[Node_size_Results]

// NewNode_size_Results creates a new list of Node_size_Results.
func NewNode_size_Results_List(s *capnp.Segment, sz int32) (Node_size_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Node_size_Results](l), err
}

// Node_size_Results_Future is a wrapper for a Node_size_Results promised by a client call.
type Node_size_Results_Future struct{ *capnp.Future }

func (f Node_size_Results_Future) Struct() (Node_size_Results, error) {
	p, err := f.Future.Ptr()
	return Node_size_Results(p.Struct()), err
}

type Link capnp.Struct

// Link_TypeID is the unique identifier for the type Link.
const Link_TypeID = 0xbf2a82aa5f13fd72

func NewLink(s *capnp.Segment) (Link, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Link(st), err
}

func NewRootLink(s *capnp.Segment) (Link, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Link(st), err
}

func ReadRootLink(msg *capnp.Message) (Link, error) {
	root, err := msg.Root()
	return Link(root.Struct()), err
}

func (s Link) String() string {
	str, _ := text.Marshal(0xbf2a82aa5f13fd72, capnp.Struct(s))
	return str
}

func (s Link) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Link) DecodeFromPtr(p capnp.Ptr) Link {
	return Link(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Link) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Link) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Link) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Link) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Link) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Link) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Link) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Link) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Link) Size() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Link) SetSize(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Link) Cid() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Link) HasCid() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Link) SetCid(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// Link_List is a list of Link.
type Link_List = capnp.StructList[Link]

// NewLink creates a new list of Link.
func NewLink_List(s *capnp.Segment, sz int32) (Link_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Link](l), err
}

// Link_Future is a wrapper for a Link promised by a client call.
type Link_Future struct{ *capnp.Future }

func (f Link_Future) Struct() (Link, error) {
	p, err := f.Future.Ptr()
	return Link(p.Struct()), err
}

type NodeStat capnp.Struct

// NodeStat_TypeID is the unique identifier for the type NodeStat.
const NodeStat_TypeID = 0xa12aaa6d6ef645a9

func NewNodeStat(s *capnp.Segment) (NodeStat, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return NodeStat(st), err
}

func NewRootNodeStat(s *capnp.Segment) (NodeStat, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1})
	return NodeStat(st), err
}

func ReadRootNodeStat(msg *capnp.Message) (NodeStat, error) {
	root, err := msg.Root()
	return NodeStat(root.Struct()), err
}

func (s NodeStat) String() string {
	str, _ := text.Marshal(0xa12aaa6d6ef645a9, capnp.Struct(s))
	return str
}

func (s NodeStat) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (NodeStat) DecodeFromPtr(p capnp.Ptr) NodeStat {
	return NodeStat(capnp.Struct{}.DecodeFromPtr(p))
}

func (s NodeStat) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s NodeStat) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s NodeStat) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s NodeStat) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s NodeStat) Hash() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s NodeStat) HasHash() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s NodeStat) SetHash(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s NodeStat) NumLinks() int32 {
	return int32(capnp.Struct(s).Uint32(0))
}

func (s NodeStat) SetNumLinks(v int32) {
	capnp.Struct(s).SetUint32(0, uint32(v))
}

func (s NodeStat) BlockSize() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s NodeStat) SetBlockSize(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s NodeStat) LinksSize() uint64 {
	return capnp.Struct(s).Uint64(16)
}

func (s NodeStat) SetLinksSize(v uint64) {
	capnp.Struct(s).SetUint64(16, v)
}

func (s NodeStat) DataSize() uint64 {
	return capnp.Struct(s).Uint64(24)
}

func (s NodeStat) SetDataSize(v uint64) {
	capnp.Struct(s).SetUint64(24, v)
}

func (s NodeStat) CumulativeSize() uint64 {
	return capnp.Struct(s).Uint64(32)
}

func (s NodeStat) SetCumulativeSize(v uint64) {
	capnp.Struct(s).SetUint64(32, v)
}

// NodeStat_List is a list of NodeStat.
type NodeStat_List = capnp.StructList[NodeStat]

// NewNodeStat creates a new list of NodeStat.
func NewNodeStat_List(s *capnp.Segment, sz int32) (NodeStat_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 40, PointerCount: 1}, sz)
	return capnp.StructList[NodeStat](l), err
}

// NodeStat_Future is a wrapper for a NodeStat promised by a client call.
type NodeStat_Future struct{ *capnp.Future }

func (f NodeStat_Future) Struct() (NodeStat, error) {
	p, err := f.Future.Ptr()
	return NodeStat(p.Struct()), err
}

const schema_dd885ad027c7a7c5 = "x\xda\x94V}\x88TU\x14?\xe7\xde7\xfbf\xc0" +
	"q\xf7\xfa6\xbfB\x06eD\xddtuw[\x02\xfb" +
	"\xd8\xc9\\\xbf\xda]\xe7\x8eA\x19\x82<g\x1e\xcd\xb4" +
	"\xf3\xb1;\xf3\xd6m\x17R\x08\xc2\x14\xcc\xb4\xad0\x14" +
	"\x0a3\xcb\x8aR3\x12\x94\xb4\xd82\xc84P\xcc\xc2" +
	"?\xd4\xbe(,\x0d2\x94\xec\xc5y3o\xe69;" +
	"\xa3\xf9\xef{\xe7\x9e\xdf\xef\xfc\xee\xef\x9cs\xe7\xbc\xc0" +
	"CJ\x93\x7f\xa9\x0f\x98Lzj\xacwfw\x9f\xb1" +
	"~\xf9r\x13\xc8\xb1\x88\x00\x1eT\x01Z6*c\x10" +
	"P{I\xe9\x07\xb4\x1ek\xee\xffc\xcd]\xdfl\x06" +
	"1\x06\x01\x14\x15@\xbb\xac\xfc\x09\x8a\x15\xbb\xfasj" +
	"\xc1\xa5\x7f\xb6\x80\xd0\x0a?ZN\xd1A\xc5\xda3p" +
	"!\xbcgx\xf2+ \xfc\xdc\x1a\xde\xf5\xc5\xb4\x13\x8f" +
	"?w\x16\x00\xb5C\xca^m\xd8NqDY\xa7\xdd" +
	"\xe1Q\x01\xac\xb7\xdb\xaf\xa4S\xbb\x1b^\x07\xe9GO" +
	")\xdaf\xa2]W\xf6j\x1e\x0akA\xcf\xa3\x08h" +
	"-?\x1f\x8fv\x9en\xdd\x09b,\xd1e\xf4K\xaf" +
	"\x89\x10\xddT\x0d\xd1\x9d\xbft\xef\x81:}\xc7\x9b#" +
	"\xb0\xcf\xd6\xbc\xaa\xfdXCI\xcf\xd5\xac\xd3\x9aT\xc2" +
	"\xbe0p\xe7\x89\x87\xbb\x9e\xdc\x95\xaf-\x0f9A\xbd" +
	"\x06\xa8MR\xdb\x00\xad\xaf\x7f\xfa\xf6\xa9\xd6E\xde}" +
	"\xf9\x12\xf3\xe2\xdc\xafN$\xb4v;@\xef=^\xb7" +
	"\xfe\xb8\xfc\xc8%\x8e\xa1\x928\xb9\x97\x17\xac\xb8g\xd3" +
	"\xec\x03\xae\x93\xdab;s\xa7}0{][\xb9\xfb" +
	"\x99\x86O\xa8jtUM\x05i)u\x8b\xd6G\x04" +
	"\xb5^\xf5}@+5\xf9\xbe\xf3\xe1_\x7f\xff\xd4\x85" +
	"\xe2\xf3^\x03\xc5Z11\x1a\x99\xd9x\xef\xd1\x82\x1a" +
	"6\xbf\x8by~\x7f\xd90g\x0e\x8f\xbb\xb4g\xfa\x89" +
	"\xa3\xa5;\xd2\xa6z\x89\xdf\x86#\xff\x8e\xf3\x7f\xf7\xdb" +
	"W \xc7\xa0;'j~/\x1d\x0c\xad\x1c\x0a\xf4_" +
	"9v\xd2\xa5L\xcb,o\x03en\xb5\x03\x96\xce\xdc" +
	"x}|v\xee)w\x80\xe1e\x14\x90\xb0\x03\x86\x06" +
	"\x8e\xedo?\xf8\xe2\xf7nm\xb7\xda\x08\xdb\xed\xff\xd6" +
	"C\x9f_]\xf3\xf7\xe9\x1fF\x9a\xc4\xbbE\x1b\xf6R" +
	"\xbe#\xde\x85\xa8m\xf4M\x03\xb0>\xdb1\xd8ui" +
	"\xdb\x03\x17]\x12<\xeb\xa3BNf\x17\x0e\xed\x93\xc3" +
	"\x97\x0b0\xb6!\x12\xbef\xe2\xd1\xeb#C\xac\xdd\xb0" +
	">\x9c\xde\xf9\xfcU\xb7F\xe7|K(\xe0\xa2\xaf\x0d" +
	"fYz:\x1a\xcfd\x1b\xa3\\\xefI\xf7\xcc\x8d\x18" +
	"\xb9Lr\xb5\x91m4\xb3\x86\x11\x0c\xebY=\x859" +
	"\xe9\xe5\x0a\x80\x82\x00bF\x03\x80\x0cr\x94s\x18\"" +
	"\xd6\x93xbV3\x80\x9c\xceQ\xde\xcd\xb0\xb6G7" +
	"\xe38\x0a\x18\x8e\x02\x0c\xc4\x8c\x1e3\x8e\x0a0T\xc8" +
	"-\x05$f#uebFc4\xd33\x10\x0c\x07" +
	"\x08&W\xc6d^2\x13\xedn\xcc\xea\xfd\xf3uS" +
	"w\x98\x14c\xd0a\x1b\xb0\xe9\x86\x11\xa5\x97{\x00\x8a" +
	"\xf5\xa2\xd3*\xa2i\x1501CE,v;:\xc6" +
	"\x11\x93\x1a\x80\x09\xa1Z\xd9|\xd9aPu3\x1e\xc2" +
	"Z\xaa>\x84a\xc42\xc0\xaeL,`,3u\x93" +
	"\x00\xc7\x17U\xd9J\xaa\x0cq\x94\xaf\x95T\xd9\xbe\x04" +
	"@n\xe3(\xdfb(\x18\xd6#\x03\x10;#\x00\xf2" +
	"\x0d\x8e\xf2\x03\x86\x82\xb3z\xe4\x00\xe2=\xfa\xf8.G" +
	"\xf91C\xa1\xf0zT\x00\xc4~:\xfe!Gy\x98" +
	"\xa1\xf0(\xf5\xe8\x01\x10\x87\x06\x01\xe4A\x8e\xf2(\xc3" +
	"\xda\xb8\x9e\x8b\xa3\x1f\x18\xfa\x01\xadt_\xaa#\x91\xee" +
	"\xce\x01@Q\xefU\xa4\xe0\xb2\xc4 \xa0\x81>`\xe8" +
	"\x03\xb4\x92\x14T\xf6-\xa6\x9b\xfa\xb2\xc4\xa0Ag\x9d" +
	"o\xd1\xbeT_R7\x13\xd0\xb6\xda\xa0\x7f\xc5\x1f\x8e" +
	"\x1e\xca\x8dvq\x04\xd4\xcdx0b\xe4\xfa\x92fU" +
	"\xdb\x88\xa2o\xb2\x00r&G\xb9\x88am:\x133" +
	"P\x94\xda\x02\x10\x05\x0d\x0a#\xa5'\xd2\x894\x04\x9e" +
	"\xa0\xdc8\x1a0\xcc\xd16\xd8h(\xbf\x9dy\xc9\x0c" +
	"\x8fv\x97\xbc\xe0\xb4?:\xe3H4M\x01&\xa6\x92" +
	"\x17\x9c\xf1\x8d\xce\x90\x13\x13\xe6\x01\x13~U\x8d&b" +
	"!\\[0\xde\x8d&(wn\xa4\xcd.5'\x95" +
	"b\xa5~\xaa\xd4\xcbQ\xd6W/\xeafF\xb7\xc5\xe3" +
	"\xd5S\xd2e\x15o\xbd\x02\xaf\x9c\xa9\x9b#:\x8a\xb9" +
	"\x80\xa2\x89XE\xdeSJ $\xc1\x08\x8c\xbc\xc4\x1d" +
	"\x894\xda\x0a\x8f*\x9el'z!\x8e\xb2\xa3d\xfe" +
	"\xc5\xf4m>G\x19v\x99\xbf\x93 \x16q\x94\x8f\x90" +
	"4z\xcap\xe6Dm\xce\xe5\xb0\x8a\xe0\xae\x02m\x07" +
	"\x07\xdb\xc2\x95f\xc6\x8d\xd3\xab\x92\x94\xcd\x85*\x83\x0c" +
	"\x034\xaar\xd5\x1cU.YeI\xf3\x92'\x06\x8d" +
	"[Z!W\xa9\x89x)I\xa1\x81\xa8\x89\x83a\xbd" +
	"\x96\xb0*\xa5\x0a:#\xb6\x0am^.T\xbe\x19s" +
	"PM\x04;\xca\xc9VWZ\xcc\x80\x15\xe4(9\xec" +
	"\x96\xe5\x9a\xba\x89u\xa5\xd7\x0d \xd6A\x85i\x8a\x06" +
	"\x99\xa9\xdenWg\xe9\xa2\xb3\xd4\xc4f\x1a\xdd\xeb\xa9" +
	"]\x9dg\x18:o\x16\xf14\x8d\xee^\x15Y\xf1}" +
	"\x80\xceR\x16F30\xb1\\E^|\xa1\xa0\xb3\x8f" +
	"E'\x9d{PE\xa5\xb8T\xd1y\x0d\x88\xd6\x06{" +
	"U8\xeb\xa0\x03\xd4D\xba;\x84\xb5\xd4\xec\xa1\x82V" +
	"\xa1|q\xa1\xfc\x95\x86Pz\xd1\xf5\xec\x02(=\xff" +
	"\x00\xaa\xba\xa5\xf2\xca\x1ba\x84\x88\x11\xc8\xab|;\x93" +
	"\x94X\x96\xddd\xdd\xff\x9f\xa47\x99\xeb\xf9\x96\x03\xb8" +
	"\x0d_\xfe\x17\x00\x00\xff\xff\x19b\x11)"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_dd885ad027c7a7c5,
		Nodes: []uint64{
			0x8fc9e8ffd96b2fab,
			0x91d12b7eef773258,
			0x92fcf0466de7f964,
			0x9721c5b150e379b1,
			0xa12aaa6d6ef645a9,
			0xa535d74d6368e259,
			0xa6a36110b9b24f44,
			0xa76a4e4bd01b79e3,
			0xb308483578d8e6ce,
			0xb651cf8910cf7161,
			0xb92f8f375c469673,
			0xbf2a82aa5f13fd72,
			0xc2eeea50e23c216d,
			0xc83b2e2c52631a5c,
			0xc8d028b1f017c0d9,
			0xccebda0d17fec18a,
			0xd4cdf6771f945f40,
			0xd53a7218fd8d2c4f,
			0xdb93bc45b5cd7994,
			0xe4d7f77ef9c643ff,
			0xed3e9cf04e7aa3c3,
			0xf1c551b3944772d4,
			0xf98ea56e50898a7f,
		},
		Compressed: true,
	})
}
