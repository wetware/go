// Code generated by capnpc-go. DO NOT EDIT.

package ww

import (
	"context"

	capnp "capnproto.org/go/capnp/v3"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
)

type Env capnp.Client

// Env_TypeID is the unique identifier for the type Env.
const Env_TypeID = 0xa799dfba4daa7d3b

func (c Env) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Env) String() string {
	return "Env(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Env) AddRef() Env {
	return Env(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Env) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Env) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Env) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Env) DecodeFromPtr(p capnp.Ptr) Env {
	return Env(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Env) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Env) IsSame(other Env) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Env) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Env) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Env_Server is a Env with a local implementation.
type Env_Server interface {
}

// Env_NewServer creates a new Server from an implementation of Env_Server.
func Env_NewServer(s Env_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Env_Methods(nil, s), s, c)
}

// Env_ServerToClient creates a new Client from an implementation of Env_Server.
// The caller is responsible for calling Release on the returned Client.
func Env_ServerToClient(s Env_Server) Env {
	return Env(capnp.NewClient(Env_NewServer(s)))
}

// Env_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Env_Methods(methods []server.Method, s Env_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 0)
	}

	return methods
}

// Env_List is a list of Env.
type Env_List = capnp.CapList[Env]

// NewEnv creates a new list of Env.
func NewEnv_List(s *capnp.Segment, sz int32) (Env_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Env](l), err
}

const schema_e82706a772b0927b = "x\xda\x12pr`1\xe4\xdd\xcf\xc8\xc0\x14(\xc2\xca" +
	"\xf6\xdf\xbav\x95\xef\xae\xfb3\x973\x08r2\xff\xaf" +
	"\x9e\xb4\xa1h9\x9b\xfa\x0b\x06\x06F\xc1\xa3Y\x82'" +
	"\xd9\x19\x18\x04\x8f\xb2\x0b\x1eeg\xd0\xf9_^\xae\x97" +
	"\x9cX\x90W\xc0\xc0o\xe5\x9aW\x16\xc0\xc8\x18\xc0\xcc" +
	"\x1a\xc0\xc8\x08\x08\x00\x00\xff\xff\xcd\xf0\x178"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_e82706a772b0927b,
		Nodes: []uint64{
			0xa799dfba4daa7d3b,
		},
		Compressed: true,
	})
}
