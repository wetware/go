// Code generated by capnpc-go. DO NOT EDIT.

package system

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
	anchor "github.com/wetware/go/anchor"
	strconv "strconv"
)

type Console capnp.Client

// Console_TypeID is the unique identifier for the type Console.
const Console_TypeID = 0xf819f53a0739f5f5

func (c Console) Println(ctx context.Context, params func(Console_println_Params) error) (Console_println_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf819f53a0739f5f5,
			MethodID:      0,
			InterfaceName: "system.capnp:Console",
			MethodName:    "println",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Console_println_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Console_println_Results_Future{Future: ans.Future()}, release

}

func (c Console) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Console) String() string {
	return "Console(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Console) AddRef() Console {
	return Console(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Console) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Console) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Console) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Console) DecodeFromPtr(p capnp.Ptr) Console {
	return Console(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Console) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Console) IsSame(other Console) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Console) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Console) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Console_Server is a Console with a local implementation.
type Console_Server interface {
	Println(context.Context, Console_println) error
}

// Console_NewServer creates a new Server from an implementation of Console_Server.
func Console_NewServer(s Console_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Console_Methods(nil, s), s, c)
}

// Console_ServerToClient creates a new Client from an implementation of Console_Server.
// The caller is responsible for calling Release on the returned Client.
func Console_ServerToClient(s Console_Server) Console {
	return Console(capnp.NewClient(Console_NewServer(s)))
}

// Console_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Console_Methods(methods []server.Method, s Console_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf819f53a0739f5f5,
			MethodID:      0,
			InterfaceName: "system.capnp:Console",
			MethodName:    "println",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Println(ctx, Console_println{call})
		},
	})

	return methods
}

// Console_println holds the state for a server call to Console.println.
// See server.Call for documentation.
type Console_println struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Console_println) Args() Console_println_Params {
	return Console_println_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Console_println) AllocResults() (Console_println_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Console_println_Results(r), err
}

// Console_List is a list of Console.
type Console_List = capnp.CapList[Console]

// NewConsole creates a new list of Console.
func NewConsole_List(s *capnp.Segment, sz int32) (Console_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Console](l), err
}

type Console_println_Params capnp.Struct

// Console_println_Params_TypeID is the unique identifier for the type Console_println_Params.
const Console_println_Params_TypeID = 0xf43754e45cb00c82

func NewConsole_println_Params(s *capnp.Segment) (Console_println_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Console_println_Params(st), err
}

func NewRootConsole_println_Params(s *capnp.Segment) (Console_println_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Console_println_Params(st), err
}

func ReadRootConsole_println_Params(msg *capnp.Message) (Console_println_Params, error) {
	root, err := msg.Root()
	return Console_println_Params(root.Struct()), err
}

func (s Console_println_Params) String() string {
	str, _ := text.Marshal(0xf43754e45cb00c82, capnp.Struct(s))
	return str
}

func (s Console_println_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Console_println_Params) DecodeFromPtr(p capnp.Ptr) Console_println_Params {
	return Console_println_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Console_println_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Console_println_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Console_println_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Console_println_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Console_println_Params) Output() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Console_println_Params) HasOutput() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Console_println_Params) OutputBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Console_println_Params) SetOutput(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Console_println_Params_List is a list of Console_println_Params.
type Console_println_Params_List = capnp.StructList[Console_println_Params]

// NewConsole_println_Params creates a new list of Console_println_Params.
func NewConsole_println_Params_List(s *capnp.Segment, sz int32) (Console_println_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Console_println_Params](l), err
}

// Console_println_Params_Future is a wrapper for a Console_println_Params promised by a client call.
type Console_println_Params_Future struct{ *capnp.Future }

func (f Console_println_Params_Future) Struct() (Console_println_Params, error) {
	p, err := f.Future.Ptr()
	return Console_println_Params(p.Struct()), err
}

type Console_println_Results capnp.Struct

// Console_println_Results_TypeID is the unique identifier for the type Console_println_Results.
const Console_println_Results_TypeID = 0x993f8e39a739cb40

func NewConsole_println_Results(s *capnp.Segment) (Console_println_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Console_println_Results(st), err
}

func NewRootConsole_println_Results(s *capnp.Segment) (Console_println_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return Console_println_Results(st), err
}

func ReadRootConsole_println_Results(msg *capnp.Message) (Console_println_Results, error) {
	root, err := msg.Root()
	return Console_println_Results(root.Struct()), err
}

func (s Console_println_Results) String() string {
	str, _ := text.Marshal(0x993f8e39a739cb40, capnp.Struct(s))
	return str
}

func (s Console_println_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Console_println_Results) DecodeFromPtr(p capnp.Ptr) Console_println_Results {
	return Console_println_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Console_println_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Console_println_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Console_println_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Console_println_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Console_println_Results) N() uint32 {
	return capnp.Struct(s).Uint32(0)
}

func (s Console_println_Results) SetN(v uint32) {
	capnp.Struct(s).SetUint32(0, v)
}

// Console_println_Results_List is a list of Console_println_Results.
type Console_println_Results_List = capnp.StructList[Console_println_Results]

// NewConsole_println_Results creates a new list of Console_println_Results.
func NewConsole_println_Results_List(s *capnp.Segment, sz int32) (Console_println_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[Console_println_Results](l), err
}

// Console_println_Results_Future is a wrapper for a Console_println_Results promised by a client call.
type Console_println_Results_Future struct{ *capnp.Future }

func (f Console_println_Results_Future) Struct() (Console_println_Results, error) {
	p, err := f.Future.Ptr()
	return Console_println_Results(p.Struct()), err
}

type Cell capnp.Client

// Cell_TypeID is the unique identifier for the type Cell.
const Cell_TypeID = 0x83eba8ab13ee9256

func (c Cell) Wait(ctx context.Context, params func(Cell_wait_Params) error) (Cell_wait_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0x83eba8ab13ee9256,
			MethodID:      0,
			InterfaceName: "system.capnp:Cell",
			MethodName:    "wait",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Cell_wait_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Cell_wait_Results_Future{Future: ans.Future()}, release

}

func (c Cell) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Cell) String() string {
	return "Cell(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Cell) AddRef() Cell {
	return Cell(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Cell) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Cell) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Cell) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Cell) DecodeFromPtr(p capnp.Ptr) Cell {
	return Cell(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Cell) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Cell) IsSame(other Cell) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Cell) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Cell) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Cell_Server is a Cell with a local implementation.
type Cell_Server interface {
	Wait(context.Context, Cell_wait) error
}

// Cell_NewServer creates a new Server from an implementation of Cell_Server.
func Cell_NewServer(s Cell_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Cell_Methods(nil, s), s, c)
}

// Cell_ServerToClient creates a new Client from an implementation of Cell_Server.
// The caller is responsible for calling Release on the returned Client.
func Cell_ServerToClient(s Cell_Server) Cell {
	return Cell(capnp.NewClient(Cell_NewServer(s)))
}

// Cell_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Cell_Methods(methods []server.Method, s Cell_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0x83eba8ab13ee9256,
			MethodID:      0,
			InterfaceName: "system.capnp:Cell",
			MethodName:    "wait",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Wait(ctx, Cell_wait{call})
		},
	})

	return methods
}

// Cell_wait holds the state for a server call to Cell.wait.
// See server.Call for documentation.
type Cell_wait struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Cell_wait) Args() Cell_wait_Params {
	return Cell_wait_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Cell_wait) AllocResults() (Cell_wait_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Cell_wait_Results(r), err
}

// Cell_List is a list of Cell.
type Cell_List = capnp.CapList[Cell]

// NewCell creates a new list of Cell.
func NewCell_List(s *capnp.Segment, sz int32) (Cell_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Cell](l), err
}

type Cell_MaybeError capnp.Struct
type Cell_MaybeError_err Cell_MaybeError
type Cell_MaybeError_Which uint16

const (
	Cell_MaybeError_Which_ok  Cell_MaybeError_Which = 0
	Cell_MaybeError_Which_err Cell_MaybeError_Which = 1
)

func (w Cell_MaybeError_Which) String() string {
	const s = "okerr"
	switch w {
	case Cell_MaybeError_Which_ok:
		return s[0:2]
	case Cell_MaybeError_Which_err:
		return s[2:5]

	}
	return "Cell_MaybeError_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Cell_MaybeError_TypeID is the unique identifier for the type Cell_MaybeError.
const Cell_MaybeError_TypeID = 0x831c74d453c6c7eb

func NewCell_MaybeError(s *capnp.Segment) (Cell_MaybeError, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Cell_MaybeError(st), err
}

func NewRootCell_MaybeError(s *capnp.Segment) (Cell_MaybeError, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Cell_MaybeError(st), err
}

func ReadRootCell_MaybeError(msg *capnp.Message) (Cell_MaybeError, error) {
	root, err := msg.Root()
	return Cell_MaybeError(root.Struct()), err
}

func (s Cell_MaybeError) String() string {
	str, _ := text.Marshal(0x831c74d453c6c7eb, capnp.Struct(s))
	return str
}

func (s Cell_MaybeError) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Cell_MaybeError) DecodeFromPtr(p capnp.Ptr) Cell_MaybeError {
	return Cell_MaybeError(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Cell_MaybeError) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Cell_MaybeError) Which() Cell_MaybeError_Which {
	return Cell_MaybeError_Which(capnp.Struct(s).Uint16(0))
}
func (s Cell_MaybeError) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Cell_MaybeError) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Cell_MaybeError) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Cell_MaybeError) SetOk() {
	capnp.Struct(s).SetUint16(0, 0)

}

func (s Cell_MaybeError) Err() Cell_MaybeError_err { return Cell_MaybeError_err(s) }

func (s Cell_MaybeError) SetErr() {
	capnp.Struct(s).SetUint16(0, 1)
}

func (s Cell_MaybeError_err) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Cell_MaybeError_err) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Cell_MaybeError_err) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Cell_MaybeError_err) Status() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s Cell_MaybeError_err) SetStatus(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

func (s Cell_MaybeError_err) Body() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Cell_MaybeError_err) HasBody() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Cell_MaybeError_err) SetBody(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// Cell_MaybeError_List is a list of Cell_MaybeError.
type Cell_MaybeError_List = capnp.StructList[Cell_MaybeError]

// NewCell_MaybeError creates a new list of Cell_MaybeError.
func NewCell_MaybeError_List(s *capnp.Segment, sz int32) (Cell_MaybeError_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Cell_MaybeError](l), err
}

// Cell_MaybeError_Future is a wrapper for a Cell_MaybeError promised by a client call.
type Cell_MaybeError_Future struct{ *capnp.Future }

func (f Cell_MaybeError_Future) Struct() (Cell_MaybeError, error) {
	p, err := f.Future.Ptr()
	return Cell_MaybeError(p.Struct()), err
}
func (p Cell_MaybeError_Future) Err() Cell_MaybeError_err_Future {
	return Cell_MaybeError_err_Future{p.Future}
}

// Cell_MaybeError_err_Future is a wrapper for a Cell_MaybeError_err promised by a client call.
type Cell_MaybeError_err_Future struct{ *capnp.Future }

func (f Cell_MaybeError_err_Future) Struct() (Cell_MaybeError_err, error) {
	p, err := f.Future.Ptr()
	return Cell_MaybeError_err(p.Struct()), err
}

type Cell_wait_Params capnp.Struct

// Cell_wait_Params_TypeID is the unique identifier for the type Cell_wait_Params.
const Cell_wait_Params_TypeID = 0xe7b7b5f24b1523f5

func NewCell_wait_Params(s *capnp.Segment) (Cell_wait_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Cell_wait_Params(st), err
}

func NewRootCell_wait_Params(s *capnp.Segment) (Cell_wait_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Cell_wait_Params(st), err
}

func ReadRootCell_wait_Params(msg *capnp.Message) (Cell_wait_Params, error) {
	root, err := msg.Root()
	return Cell_wait_Params(root.Struct()), err
}

func (s Cell_wait_Params) String() string {
	str, _ := text.Marshal(0xe7b7b5f24b1523f5, capnp.Struct(s))
	return str
}

func (s Cell_wait_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Cell_wait_Params) DecodeFromPtr(p capnp.Ptr) Cell_wait_Params {
	return Cell_wait_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Cell_wait_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Cell_wait_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Cell_wait_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Cell_wait_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Cell_wait_Params_List is a list of Cell_wait_Params.
type Cell_wait_Params_List = capnp.StructList[Cell_wait_Params]

// NewCell_wait_Params creates a new list of Cell_wait_Params.
func NewCell_wait_Params_List(s *capnp.Segment, sz int32) (Cell_wait_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Cell_wait_Params](l), err
}

// Cell_wait_Params_Future is a wrapper for a Cell_wait_Params promised by a client call.
type Cell_wait_Params_Future struct{ *capnp.Future }

func (f Cell_wait_Params_Future) Struct() (Cell_wait_Params, error) {
	p, err := f.Future.Ptr()
	return Cell_wait_Params(p.Struct()), err
}

type Cell_wait_Results capnp.Struct

// Cell_wait_Results_TypeID is the unique identifier for the type Cell_wait_Results.
const Cell_wait_Results_TypeID = 0xcb1c584d5e6ec593

func NewCell_wait_Results(s *capnp.Segment) (Cell_wait_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Cell_wait_Results(st), err
}

func NewRootCell_wait_Results(s *capnp.Segment) (Cell_wait_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Cell_wait_Results(st), err
}

func ReadRootCell_wait_Results(msg *capnp.Message) (Cell_wait_Results, error) {
	root, err := msg.Root()
	return Cell_wait_Results(root.Struct()), err
}

func (s Cell_wait_Results) String() string {
	str, _ := text.Marshal(0xcb1c584d5e6ec593, capnp.Struct(s))
	return str
}

func (s Cell_wait_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Cell_wait_Results) DecodeFromPtr(p capnp.Ptr) Cell_wait_Results {
	return Cell_wait_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Cell_wait_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Cell_wait_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Cell_wait_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Cell_wait_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Cell_wait_Results) Result() (Cell_MaybeError, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Cell_MaybeError(p.Struct()), err
}

func (s Cell_wait_Results) HasResult() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Cell_wait_Results) SetResult(v Cell_MaybeError) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewResult sets the result field to a newly
// allocated Cell_MaybeError struct, preferring placement in s's segment.
func (s Cell_wait_Results) NewResult() (Cell_MaybeError, error) {
	ss, err := NewCell_MaybeError(capnp.Struct(s).Segment())
	if err != nil {
		return Cell_MaybeError{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Cell_wait_Results_List is a list of Cell_wait_Results.
type Cell_wait_Results_List = capnp.StructList[Cell_wait_Results]

// NewCell_wait_Results creates a new list of Cell_wait_Results.
func NewCell_wait_Results_List(s *capnp.Segment, sz int32) (Cell_wait_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Cell_wait_Results](l), err
}

// Cell_wait_Results_Future is a wrapper for a Cell_wait_Results promised by a client call.
type Cell_wait_Results_Future struct{ *capnp.Future }

func (f Cell_wait_Results_Future) Struct() (Cell_wait_Results, error) {
	p, err := f.Future.Ptr()
	return Cell_wait_Results(p.Struct()), err
}
func (p Cell_wait_Results_Future) Result() Cell_MaybeError_Future {
	return Cell_MaybeError_Future{Future: p.Future.Field(0, nil)}
}

type Executor capnp.Client

// Executor_TypeID is the unique identifier for the type Executor.
const Executor_TypeID = 0xccef5e6e46834543

func (c Executor) Spawn(ctx context.Context, params func(Executor_spawn_Params) error) (Executor_spawn_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xccef5e6e46834543,
			MethodID:      0,
			InterfaceName: "system.capnp:Executor",
			MethodName:    "spawn",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 2}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Executor_spawn_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Executor_spawn_Results_Future{Future: ans.Future()}, release

}

func (c Executor) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Executor) String() string {
	return "Executor(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Executor) AddRef() Executor {
	return Executor(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Executor) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Executor) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Executor) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Executor) DecodeFromPtr(p capnp.Ptr) Executor {
	return Executor(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Executor) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Executor) IsSame(other Executor) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Executor) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Executor) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Executor_Server is a Executor with a local implementation.
type Executor_Server interface {
	Spawn(context.Context, Executor_spawn) error
}

// Executor_NewServer creates a new Server from an implementation of Executor_Server.
func Executor_NewServer(s Executor_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Executor_Methods(nil, s), s, c)
}

// Executor_ServerToClient creates a new Client from an implementation of Executor_Server.
// The caller is responsible for calling Release on the returned Client.
func Executor_ServerToClient(s Executor_Server) Executor {
	return Executor(capnp.NewClient(Executor_NewServer(s)))
}

// Executor_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Executor_Methods(methods []server.Method, s Executor_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 1)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xccef5e6e46834543,
			MethodID:      0,
			InterfaceName: "system.capnp:Executor",
			MethodName:    "spawn",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Spawn(ctx, Executor_spawn{call})
		},
	})

	return methods
}

// Executor_spawn holds the state for a server call to Executor.spawn.
// See server.Call for documentation.
type Executor_spawn struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Executor_spawn) Args() Executor_spawn_Params {
	return Executor_spawn_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Executor_spawn) AllocResults() (Executor_spawn_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Executor_spawn_Results(r), err
}

// Executor_List is a list of Executor.
type Executor_List = capnp.CapList[Executor]

// NewExecutor creates a new list of Executor.
func NewExecutor_List(s *capnp.Segment, sz int32) (Executor_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Executor](l), err
}

type Executor_Command capnp.Struct

// Executor_Command_TypeID is the unique identifier for the type Executor_Command.
const Executor_Command_TypeID = 0xa31767d7d652c0cb

func NewExecutor_Command(s *capnp.Segment) (Executor_Command, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return Executor_Command(st), err
}

func NewRootExecutor_Command(s *capnp.Segment) (Executor_Command, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5})
	return Executor_Command(st), err
}

func ReadRootExecutor_Command(msg *capnp.Message) (Executor_Command, error) {
	root, err := msg.Root()
	return Executor_Command(root.Struct()), err
}

func (s Executor_Command) String() string {
	str, _ := text.Marshal(0xa31767d7d652c0cb, capnp.Struct(s))
	return str
}

func (s Executor_Command) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Executor_Command) DecodeFromPtr(p capnp.Ptr) Executor_Command {
	return Executor_Command(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Executor_Command) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Executor_Command) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Executor_Command) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Executor_Command) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Executor_Command) Path() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Executor_Command) HasPath() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Executor_Command) PathBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Executor_Command) SetPath(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Executor_Command) Args() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s Executor_Command) HasArgs() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Executor_Command) SetArgs(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewArgs sets the args field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Executor_Command) NewArgs(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Executor_Command) Env() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.TextList(p.List()), err
}

func (s Executor_Command) HasEnv() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Executor_Command) SetEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewEnv sets the env field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Executor_Command) NewEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}
func (s Executor_Command) Dir() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Executor_Command) HasDir() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Executor_Command) DirBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Executor_Command) SetDir(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Executor_Command) ExtraCaps() (Executor_Command_CapDescriptor_List, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return Executor_Command_CapDescriptor_List(p.List()), err
}

func (s Executor_Command) HasExtraCaps() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Executor_Command) SetExtraCaps(v Executor_Command_CapDescriptor_List) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewExtraCaps sets the extraCaps field to a newly
// allocated Executor_Command_CapDescriptor_List, preferring placement in s's segment.
func (s Executor_Command) NewExtraCaps(n int32) (Executor_Command_CapDescriptor_List, error) {
	l, err := NewExecutor_Command_CapDescriptor_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Executor_Command_CapDescriptor_List{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}

// Executor_Command_List is a list of Executor_Command.
type Executor_Command_List = capnp.StructList[Executor_Command]

// NewExecutor_Command creates a new list of Executor_Command.
func NewExecutor_Command_List(s *capnp.Segment, sz int32) (Executor_Command_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 5}, sz)
	return capnp.StructList[Executor_Command](l), err
}

// Executor_Command_Future is a wrapper for a Executor_Command promised by a client call.
type Executor_Command_Future struct{ *capnp.Future }

func (f Executor_Command_Future) Struct() (Executor_Command, error) {
	p, err := f.Future.Ptr()
	return Executor_Command(p.Struct()), err
}

type Executor_Command_CapDescriptor capnp.Struct

// Executor_Command_CapDescriptor_TypeID is the unique identifier for the type Executor_Command_CapDescriptor.
const Executor_Command_CapDescriptor_TypeID = 0xcd9913609a5c2ef6

func NewExecutor_Command_CapDescriptor(s *capnp.Segment) (Executor_Command_CapDescriptor, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Executor_Command_CapDescriptor(st), err
}

func NewRootExecutor_Command_CapDescriptor(s *capnp.Segment) (Executor_Command_CapDescriptor, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Executor_Command_CapDescriptor(st), err
}

func ReadRootExecutor_Command_CapDescriptor(msg *capnp.Message) (Executor_Command_CapDescriptor, error) {
	root, err := msg.Root()
	return Executor_Command_CapDescriptor(root.Struct()), err
}

func (s Executor_Command_CapDescriptor) String() string {
	str, _ := text.Marshal(0xcd9913609a5c2ef6, capnp.Struct(s))
	return str
}

func (s Executor_Command_CapDescriptor) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Executor_Command_CapDescriptor) DecodeFromPtr(p capnp.Ptr) Executor_Command_CapDescriptor {
	return Executor_Command_CapDescriptor(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Executor_Command_CapDescriptor) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Executor_Command_CapDescriptor) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Executor_Command_CapDescriptor) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Executor_Command_CapDescriptor) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Executor_Command_CapDescriptor) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Executor_Command_CapDescriptor) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Executor_Command_CapDescriptor) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Executor_Command_CapDescriptor) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Executor_Command_CapDescriptor) Client() capnp.Client {
	p, _ := capnp.Struct(s).Ptr(1)
	return p.Interface().Client()
}

func (s Executor_Command_CapDescriptor) HasClient() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Executor_Command_CapDescriptor) SetClient(c capnp.Client) error {
	if !c.IsValid() {
		return capnp.Struct(s).SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(c))
	return capnp.Struct(s).SetPtr(1, in.ToPtr())
}

// Executor_Command_CapDescriptor_List is a list of Executor_Command_CapDescriptor.
type Executor_Command_CapDescriptor_List = capnp.StructList[Executor_Command_CapDescriptor]

// NewExecutor_Command_CapDescriptor creates a new list of Executor_Command_CapDescriptor.
func NewExecutor_Command_CapDescriptor_List(s *capnp.Segment, sz int32) (Executor_Command_CapDescriptor_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Executor_Command_CapDescriptor](l), err
}

// Executor_Command_CapDescriptor_Future is a wrapper for a Executor_Command_CapDescriptor promised by a client call.
type Executor_Command_CapDescriptor_Future struct{ *capnp.Future }

func (f Executor_Command_CapDescriptor_Future) Struct() (Executor_Command_CapDescriptor, error) {
	p, err := f.Future.Ptr()
	return Executor_Command_CapDescriptor(p.Struct()), err
}
func (p Executor_Command_CapDescriptor_Future) Client() capnp.Client {
	return p.Future.Field(1, nil).Client()
}

type Executor_OptionalCell capnp.Struct
type Executor_OptionalCell_err Executor_OptionalCell
type Executor_OptionalCell_Which uint16

const (
	Executor_OptionalCell_Which_cell Executor_OptionalCell_Which = 0
	Executor_OptionalCell_Which_err  Executor_OptionalCell_Which = 1
)

func (w Executor_OptionalCell_Which) String() string {
	const s = "cellerr"
	switch w {
	case Executor_OptionalCell_Which_cell:
		return s[0:4]
	case Executor_OptionalCell_Which_err:
		return s[4:7]

	}
	return "Executor_OptionalCell_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Executor_OptionalCell_TypeID is the unique identifier for the type Executor_OptionalCell.
const Executor_OptionalCell_TypeID = 0xb7eddbdee842c46a

func NewExecutor_OptionalCell(s *capnp.Segment) (Executor_OptionalCell, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Executor_OptionalCell(st), err
}

func NewRootExecutor_OptionalCell(s *capnp.Segment) (Executor_OptionalCell, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Executor_OptionalCell(st), err
}

func ReadRootExecutor_OptionalCell(msg *capnp.Message) (Executor_OptionalCell, error) {
	root, err := msg.Root()
	return Executor_OptionalCell(root.Struct()), err
}

func (s Executor_OptionalCell) String() string {
	str, _ := text.Marshal(0xb7eddbdee842c46a, capnp.Struct(s))
	return str
}

func (s Executor_OptionalCell) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Executor_OptionalCell) DecodeFromPtr(p capnp.Ptr) Executor_OptionalCell {
	return Executor_OptionalCell(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Executor_OptionalCell) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Executor_OptionalCell) Which() Executor_OptionalCell_Which {
	return Executor_OptionalCell_Which(capnp.Struct(s).Uint16(0))
}
func (s Executor_OptionalCell) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Executor_OptionalCell) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Executor_OptionalCell) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Executor_OptionalCell) Cell() Cell {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != cell")
	}
	p, _ := capnp.Struct(s).Ptr(0)
	return Cell(p.Interface().Client())
}

func (s Executor_OptionalCell) HasCell() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Executor_OptionalCell) SetCell(v Cell) error {
	capnp.Struct(s).SetUint16(0, 0)
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s Executor_OptionalCell) Err() Executor_OptionalCell_err { return Executor_OptionalCell_err(s) }

func (s Executor_OptionalCell) SetErr() {
	capnp.Struct(s).SetUint16(0, 1)
}

func (s Executor_OptionalCell_err) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Executor_OptionalCell_err) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Executor_OptionalCell_err) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Executor_OptionalCell_err) Status() uint32 {
	return capnp.Struct(s).Uint32(4)
}

func (s Executor_OptionalCell_err) SetStatus(v uint32) {
	capnp.Struct(s).SetUint32(4, v)
}

func (s Executor_OptionalCell_err) Body() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Executor_OptionalCell_err) HasBody() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Executor_OptionalCell_err) SetBody(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// Executor_OptionalCell_List is a list of Executor_OptionalCell.
type Executor_OptionalCell_List = capnp.StructList[Executor_OptionalCell]

// NewExecutor_OptionalCell creates a new list of Executor_OptionalCell.
func NewExecutor_OptionalCell_List(s *capnp.Segment, sz int32) (Executor_OptionalCell_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Executor_OptionalCell](l), err
}

// Executor_OptionalCell_Future is a wrapper for a Executor_OptionalCell promised by a client call.
type Executor_OptionalCell_Future struct{ *capnp.Future }

func (f Executor_OptionalCell_Future) Struct() (Executor_OptionalCell, error) {
	p, err := f.Future.Ptr()
	return Executor_OptionalCell(p.Struct()), err
}
func (p Executor_OptionalCell_Future) Cell() Cell {
	return Cell(p.Future.Field(0, nil).Client())
}

func (p Executor_OptionalCell_Future) Err() Executor_OptionalCell_err_Future {
	return Executor_OptionalCell_err_Future{p.Future}
}

// Executor_OptionalCell_err_Future is a wrapper for a Executor_OptionalCell_err promised by a client call.
type Executor_OptionalCell_err_Future struct{ *capnp.Future }

func (f Executor_OptionalCell_err_Future) Struct() (Executor_OptionalCell_err, error) {
	p, err := f.Future.Ptr()
	return Executor_OptionalCell_err(p.Struct()), err
}

type Executor_spawn_Params capnp.Struct

// Executor_spawn_Params_TypeID is the unique identifier for the type Executor_spawn_Params.
const Executor_spawn_Params_TypeID = 0xb8078038290eb30b

func NewExecutor_spawn_Params(s *capnp.Segment) (Executor_spawn_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Executor_spawn_Params(st), err
}

func NewRootExecutor_spawn_Params(s *capnp.Segment) (Executor_spawn_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Executor_spawn_Params(st), err
}

func ReadRootExecutor_spawn_Params(msg *capnp.Message) (Executor_spawn_Params, error) {
	root, err := msg.Root()
	return Executor_spawn_Params(root.Struct()), err
}

func (s Executor_spawn_Params) String() string {
	str, _ := text.Marshal(0xb8078038290eb30b, capnp.Struct(s))
	return str
}

func (s Executor_spawn_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Executor_spawn_Params) DecodeFromPtr(p capnp.Ptr) Executor_spawn_Params {
	return Executor_spawn_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Executor_spawn_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Executor_spawn_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Executor_spawn_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Executor_spawn_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Executor_spawn_Params) IPFS() IPFS {
	p, _ := capnp.Struct(s).Ptr(0)
	return IPFS(p.Interface().Client())
}

func (s Executor_spawn_Params) HasIPFS() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Executor_spawn_Params) SetIPFS(v IPFS) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

func (s Executor_spawn_Params) Command() (Executor_Command, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Executor_Command(p.Struct()), err
}

func (s Executor_spawn_Params) HasCommand() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Executor_spawn_Params) SetCommand(v Executor_Command) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewCommand sets the command field to a newly
// allocated Executor_Command struct, preferring placement in s's segment.
func (s Executor_spawn_Params) NewCommand() (Executor_Command, error) {
	ss, err := NewExecutor_Command(capnp.Struct(s).Segment())
	if err != nil {
		return Executor_Command{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Executor_spawn_Params_List is a list of Executor_spawn_Params.
type Executor_spawn_Params_List = capnp.StructList[Executor_spawn_Params]

// NewExecutor_spawn_Params creates a new list of Executor_spawn_Params.
func NewExecutor_spawn_Params_List(s *capnp.Segment, sz int32) (Executor_spawn_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Executor_spawn_Params](l), err
}

// Executor_spawn_Params_Future is a wrapper for a Executor_spawn_Params promised by a client call.
type Executor_spawn_Params_Future struct{ *capnp.Future }

func (f Executor_spawn_Params_Future) Struct() (Executor_spawn_Params, error) {
	p, err := f.Future.Ptr()
	return Executor_spawn_Params(p.Struct()), err
}
func (p Executor_spawn_Params_Future) IPFS() IPFS {
	return IPFS(p.Future.Field(0, nil).Client())
}

func (p Executor_spawn_Params_Future) Command() Executor_Command_Future {
	return Executor_Command_Future{Future: p.Future.Field(1, nil)}
}

type Executor_spawn_Results capnp.Struct

// Executor_spawn_Results_TypeID is the unique identifier for the type Executor_spawn_Results.
const Executor_spawn_Results_TypeID = 0xa04c2cd2ed66b51c

func NewExecutor_spawn_Results(s *capnp.Segment) (Executor_spawn_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Executor_spawn_Results(st), err
}

func NewRootExecutor_spawn_Results(s *capnp.Segment) (Executor_spawn_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Executor_spawn_Results(st), err
}

func ReadRootExecutor_spawn_Results(msg *capnp.Message) (Executor_spawn_Results, error) {
	root, err := msg.Root()
	return Executor_spawn_Results(root.Struct()), err
}

func (s Executor_spawn_Results) String() string {
	str, _ := text.Marshal(0xa04c2cd2ed66b51c, capnp.Struct(s))
	return str
}

func (s Executor_spawn_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Executor_spawn_Results) DecodeFromPtr(p capnp.Ptr) Executor_spawn_Results {
	return Executor_spawn_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Executor_spawn_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Executor_spawn_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Executor_spawn_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Executor_spawn_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Executor_spawn_Results) Cell() (Executor_OptionalCell, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Executor_OptionalCell(p.Struct()), err
}

func (s Executor_spawn_Results) HasCell() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Executor_spawn_Results) SetCell(v Executor_OptionalCell) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewCell sets the cell field to a newly
// allocated Executor_OptionalCell struct, preferring placement in s's segment.
func (s Executor_spawn_Results) NewCell() (Executor_OptionalCell, error) {
	ss, err := NewExecutor_OptionalCell(capnp.Struct(s).Segment())
	if err != nil {
		return Executor_OptionalCell{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Executor_spawn_Results_List is a list of Executor_spawn_Results.
type Executor_spawn_Results_List = capnp.StructList[Executor_spawn_Results]

// NewExecutor_spawn_Results creates a new list of Executor_spawn_Results.
func NewExecutor_spawn_Results_List(s *capnp.Segment, sz int32) (Executor_spawn_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Executor_spawn_Results](l), err
}

// Executor_spawn_Results_Future is a wrapper for a Executor_spawn_Results promised by a client call.
type Executor_spawn_Results_Future struct{ *capnp.Future }

func (f Executor_spawn_Results_Future) Struct() (Executor_spawn_Results, error) {
	p, err := f.Future.Ptr()
	return Executor_spawn_Results(p.Struct()), err
}
func (p Executor_spawn_Results_Future) Cell() Executor_OptionalCell_Future {
	return Executor_OptionalCell_Future{Future: p.Future.Field(0, nil)}
}

type IPFS capnp.Client

// IPFS_TypeID is the unique identifier for the type IPFS.
const IPFS_TypeID = 0xf07e5f02273b1d4b

func (c IPFS) Add(ctx context.Context, params func(IPFS_add_Params) error) (IPFS_add_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      0,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "add",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_add_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_add_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Cat(ctx context.Context, params func(IPFS_cat_Params) error) (IPFS_cat_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      1,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "cat",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_cat_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_cat_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Ls(ctx context.Context, params func(IPFS_ls_Params) error) (IPFS_ls_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      2,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "ls",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_ls_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_ls_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Stat(ctx context.Context, params func(IPFS_stat_Params) error) (IPFS_stat_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      3,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "stat",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_stat_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_stat_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Pin(ctx context.Context, params func(IPFS_pin_Params) error) (IPFS_pin_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      4,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "pin",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_pin_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_pin_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Unpin(ctx context.Context, params func(IPFS_unpin_Params) error) (IPFS_unpin_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      5,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "unpin",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_unpin_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_unpin_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Pins(ctx context.Context, params func(IPFS_pins_Params) error) (IPFS_pins_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      6,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "pins",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_pins_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_pins_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Id(ctx context.Context, params func(IPFS_id_Params) error) (IPFS_id_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      7,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "id",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_id_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_id_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Connect(ctx context.Context, params func(IPFS_connect_Params) error) (IPFS_connect_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      8,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "connect",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_connect_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_connect_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Peers(ctx context.Context, params func(IPFS_peers_Params) error) (IPFS_peers_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      9,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "peers",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_peers_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_peers_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) ResolveNode(ctx context.Context, params func(IPFS_resolveNode_Params) error) (IPFS_resolveNode_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      10,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "resolveNode",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_resolveNode_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_resolveNode_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c IPFS) String() string {
	return "IPFS(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c IPFS) AddRef() IPFS {
	return IPFS(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c IPFS) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c IPFS) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c IPFS) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (IPFS) DecodeFromPtr(p capnp.Ptr) IPFS {
	return IPFS(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c IPFS) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c IPFS) IsSame(other IPFS) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c IPFS) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c IPFS) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A IPFS_Server is a IPFS with a local implementation.
type IPFS_Server interface {
	Add(context.Context, IPFS_add) error

	Cat(context.Context, IPFS_cat) error

	Ls(context.Context, IPFS_ls) error

	Stat(context.Context, IPFS_stat) error

	Pin(context.Context, IPFS_pin) error

	Unpin(context.Context, IPFS_unpin) error

	Pins(context.Context, IPFS_pins) error

	Id(context.Context, IPFS_id) error

	Connect(context.Context, IPFS_connect) error

	Peers(context.Context, IPFS_peers) error

	ResolveNode(context.Context, IPFS_resolveNode) error
}

// IPFS_NewServer creates a new Server from an implementation of IPFS_Server.
func IPFS_NewServer(s IPFS_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(IPFS_Methods(nil, s), s, c)
}

// IPFS_ServerToClient creates a new Client from an implementation of IPFS_Server.
// The caller is responsible for calling Release on the returned Client.
func IPFS_ServerToClient(s IPFS_Server) IPFS {
	return IPFS(capnp.NewClient(IPFS_NewServer(s)))
}

// IPFS_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func IPFS_Methods(methods []server.Method, s IPFS_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 11)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      0,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "add",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Add(ctx, IPFS_add{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      1,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "cat",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Cat(ctx, IPFS_cat{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      2,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "ls",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Ls(ctx, IPFS_ls{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      3,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "stat",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Stat(ctx, IPFS_stat{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      4,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "pin",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Pin(ctx, IPFS_pin{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      5,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "unpin",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Unpin(ctx, IPFS_unpin{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      6,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "pins",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Pins(ctx, IPFS_pins{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      7,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "id",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Id(ctx, IPFS_id{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      8,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "connect",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Connect(ctx, IPFS_connect{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      9,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "peers",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Peers(ctx, IPFS_peers{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      10,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "resolveNode",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.ResolveNode(ctx, IPFS_resolveNode{call})
		},
	})

	return methods
}

// IPFS_add holds the state for a server call to IPFS.add.
// See server.Call for documentation.
type IPFS_add struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_add) Args() IPFS_add_Params {
	return IPFS_add_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_add) AllocResults() (IPFS_add_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_add_Results(r), err
}

// IPFS_cat holds the state for a server call to IPFS.cat.
// See server.Call for documentation.
type IPFS_cat struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_cat) Args() IPFS_cat_Params {
	return IPFS_cat_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_cat) AllocResults() (IPFS_cat_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_cat_Results(r), err
}

// IPFS_ls holds the state for a server call to IPFS.ls.
// See server.Call for documentation.
type IPFS_ls struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_ls) Args() IPFS_ls_Params {
	return IPFS_ls_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_ls) AllocResults() (IPFS_ls_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_ls_Results(r), err
}

// IPFS_stat holds the state for a server call to IPFS.stat.
// See server.Call for documentation.
type IPFS_stat struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_stat) Args() IPFS_stat_Params {
	return IPFS_stat_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_stat) AllocResults() (IPFS_stat_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_stat_Results(r), err
}

// IPFS_pin holds the state for a server call to IPFS.pin.
// See server.Call for documentation.
type IPFS_pin struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_pin) Args() IPFS_pin_Params {
	return IPFS_pin_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_pin) AllocResults() (IPFS_pin_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_pin_Results(r), err
}

// IPFS_unpin holds the state for a server call to IPFS.unpin.
// See server.Call for documentation.
type IPFS_unpin struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_unpin) Args() IPFS_unpin_Params {
	return IPFS_unpin_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_unpin) AllocResults() (IPFS_unpin_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_unpin_Results(r), err
}

// IPFS_pins holds the state for a server call to IPFS.pins.
// See server.Call for documentation.
type IPFS_pins struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_pins) Args() IPFS_pins_Params {
	return IPFS_pins_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_pins) AllocResults() (IPFS_pins_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_pins_Results(r), err
}

// IPFS_id holds the state for a server call to IPFS.id.
// See server.Call for documentation.
type IPFS_id struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_id) Args() IPFS_id_Params {
	return IPFS_id_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_id) AllocResults() (IPFS_id_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_id_Results(r), err
}

// IPFS_connect holds the state for a server call to IPFS.connect.
// See server.Call for documentation.
type IPFS_connect struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_connect) Args() IPFS_connect_Params {
	return IPFS_connect_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_connect) AllocResults() (IPFS_connect_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_connect_Results(r), err
}

// IPFS_peers holds the state for a server call to IPFS.peers.
// See server.Call for documentation.
type IPFS_peers struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_peers) Args() IPFS_peers_Params {
	return IPFS_peers_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_peers) AllocResults() (IPFS_peers_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_peers_Results(r), err
}

// IPFS_resolveNode holds the state for a server call to IPFS.resolveNode.
// See server.Call for documentation.
type IPFS_resolveNode struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_resolveNode) Args() IPFS_resolveNode_Params {
	return IPFS_resolveNode_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_resolveNode) AllocResults() (IPFS_resolveNode_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return IPFS_resolveNode_Results(r), err
}

// IPFS_List is a list of IPFS.
type IPFS_List = capnp.CapList[IPFS]

// NewIPFS creates a new list of IPFS.
func NewIPFS_List(s *capnp.Segment, sz int32) (IPFS_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[IPFS](l), err
}

type IPFS_add_Params capnp.Struct

// IPFS_add_Params_TypeID is the unique identifier for the type IPFS_add_Params.
const IPFS_add_Params_TypeID = 0xd44a8470fbc0385e

func NewIPFS_add_Params(s *capnp.Segment) (IPFS_add_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_add_Params(st), err
}

func NewRootIPFS_add_Params(s *capnp.Segment) (IPFS_add_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_add_Params(st), err
}

func ReadRootIPFS_add_Params(msg *capnp.Message) (IPFS_add_Params, error) {
	root, err := msg.Root()
	return IPFS_add_Params(root.Struct()), err
}

func (s IPFS_add_Params) String() string {
	str, _ := text.Marshal(0xd44a8470fbc0385e, capnp.Struct(s))
	return str
}

func (s IPFS_add_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_add_Params) DecodeFromPtr(p capnp.Ptr) IPFS_add_Params {
	return IPFS_add_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_add_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_add_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_add_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_add_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_add_Params) Data() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s IPFS_add_Params) HasData() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_add_Params) SetData(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// IPFS_add_Params_List is a list of IPFS_add_Params.
type IPFS_add_Params_List = capnp.StructList[IPFS_add_Params]

// NewIPFS_add_Params creates a new list of IPFS_add_Params.
func NewIPFS_add_Params_List(s *capnp.Segment, sz int32) (IPFS_add_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_add_Params](l), err
}

// IPFS_add_Params_Future is a wrapper for a IPFS_add_Params promised by a client call.
type IPFS_add_Params_Future struct{ *capnp.Future }

func (f IPFS_add_Params_Future) Struct() (IPFS_add_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_add_Params(p.Struct()), err
}

type IPFS_add_Results capnp.Struct

// IPFS_add_Results_TypeID is the unique identifier for the type IPFS_add_Results.
const IPFS_add_Results_TypeID = 0xd6c02c9d5a3500b3

func NewIPFS_add_Results(s *capnp.Segment) (IPFS_add_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_add_Results(st), err
}

func NewRootIPFS_add_Results(s *capnp.Segment) (IPFS_add_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_add_Results(st), err
}

func ReadRootIPFS_add_Results(msg *capnp.Message) (IPFS_add_Results, error) {
	root, err := msg.Root()
	return IPFS_add_Results(root.Struct()), err
}

func (s IPFS_add_Results) String() string {
	str, _ := text.Marshal(0xd6c02c9d5a3500b3, capnp.Struct(s))
	return str
}

func (s IPFS_add_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_add_Results) DecodeFromPtr(p capnp.Ptr) IPFS_add_Results {
	return IPFS_add_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_add_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_add_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_add_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_add_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_add_Results) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_add_Results) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_add_Results) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_add_Results) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_add_Results_List is a list of IPFS_add_Results.
type IPFS_add_Results_List = capnp.StructList[IPFS_add_Results]

// NewIPFS_add_Results creates a new list of IPFS_add_Results.
func NewIPFS_add_Results_List(s *capnp.Segment, sz int32) (IPFS_add_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_add_Results](l), err
}

// IPFS_add_Results_Future is a wrapper for a IPFS_add_Results promised by a client call.
type IPFS_add_Results_Future struct{ *capnp.Future }

func (f IPFS_add_Results_Future) Struct() (IPFS_add_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_add_Results(p.Struct()), err
}

type IPFS_cat_Params capnp.Struct

// IPFS_cat_Params_TypeID is the unique identifier for the type IPFS_cat_Params.
const IPFS_cat_Params_TypeID = 0xadaaae7523bdc7e4

func NewIPFS_cat_Params(s *capnp.Segment) (IPFS_cat_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_cat_Params(st), err
}

func NewRootIPFS_cat_Params(s *capnp.Segment) (IPFS_cat_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_cat_Params(st), err
}

func ReadRootIPFS_cat_Params(msg *capnp.Message) (IPFS_cat_Params, error) {
	root, err := msg.Root()
	return IPFS_cat_Params(root.Struct()), err
}

func (s IPFS_cat_Params) String() string {
	str, _ := text.Marshal(0xadaaae7523bdc7e4, capnp.Struct(s))
	return str
}

func (s IPFS_cat_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_cat_Params) DecodeFromPtr(p capnp.Ptr) IPFS_cat_Params {
	return IPFS_cat_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_cat_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_cat_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_cat_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_cat_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_cat_Params) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_cat_Params) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_cat_Params) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_cat_Params) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_cat_Params_List is a list of IPFS_cat_Params.
type IPFS_cat_Params_List = capnp.StructList[IPFS_cat_Params]

// NewIPFS_cat_Params creates a new list of IPFS_cat_Params.
func NewIPFS_cat_Params_List(s *capnp.Segment, sz int32) (IPFS_cat_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_cat_Params](l), err
}

// IPFS_cat_Params_Future is a wrapper for a IPFS_cat_Params promised by a client call.
type IPFS_cat_Params_Future struct{ *capnp.Future }

func (f IPFS_cat_Params_Future) Struct() (IPFS_cat_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_cat_Params(p.Struct()), err
}

type IPFS_cat_Results capnp.Struct

// IPFS_cat_Results_TypeID is the unique identifier for the type IPFS_cat_Results.
const IPFS_cat_Results_TypeID = 0xcb3a96057ca67436

func NewIPFS_cat_Results(s *capnp.Segment) (IPFS_cat_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_cat_Results(st), err
}

func NewRootIPFS_cat_Results(s *capnp.Segment) (IPFS_cat_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_cat_Results(st), err
}

func ReadRootIPFS_cat_Results(msg *capnp.Message) (IPFS_cat_Results, error) {
	root, err := msg.Root()
	return IPFS_cat_Results(root.Struct()), err
}

func (s IPFS_cat_Results) String() string {
	str, _ := text.Marshal(0xcb3a96057ca67436, capnp.Struct(s))
	return str
}

func (s IPFS_cat_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_cat_Results) DecodeFromPtr(p capnp.Ptr) IPFS_cat_Results {
	return IPFS_cat_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_cat_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_cat_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_cat_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_cat_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_cat_Results) Body() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s IPFS_cat_Results) HasBody() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_cat_Results) SetBody(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// IPFS_cat_Results_List is a list of IPFS_cat_Results.
type IPFS_cat_Results_List = capnp.StructList[IPFS_cat_Results]

// NewIPFS_cat_Results creates a new list of IPFS_cat_Results.
func NewIPFS_cat_Results_List(s *capnp.Segment, sz int32) (IPFS_cat_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_cat_Results](l), err
}

// IPFS_cat_Results_Future is a wrapper for a IPFS_cat_Results promised by a client call.
type IPFS_cat_Results_Future struct{ *capnp.Future }

func (f IPFS_cat_Results_Future) Struct() (IPFS_cat_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_cat_Results(p.Struct()), err
}

type IPFS_ls_Params capnp.Struct

// IPFS_ls_Params_TypeID is the unique identifier for the type IPFS_ls_Params.
const IPFS_ls_Params_TypeID = 0xaadf1b3f02f6ff23

func NewIPFS_ls_Params(s *capnp.Segment) (IPFS_ls_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_ls_Params(st), err
}

func NewRootIPFS_ls_Params(s *capnp.Segment) (IPFS_ls_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_ls_Params(st), err
}

func ReadRootIPFS_ls_Params(msg *capnp.Message) (IPFS_ls_Params, error) {
	root, err := msg.Root()
	return IPFS_ls_Params(root.Struct()), err
}

func (s IPFS_ls_Params) String() string {
	str, _ := text.Marshal(0xaadf1b3f02f6ff23, capnp.Struct(s))
	return str
}

func (s IPFS_ls_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_ls_Params) DecodeFromPtr(p capnp.Ptr) IPFS_ls_Params {
	return IPFS_ls_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_ls_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_ls_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_ls_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_ls_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_ls_Params) Path() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_ls_Params) HasPath() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_ls_Params) PathBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_ls_Params) SetPath(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_ls_Params_List is a list of IPFS_ls_Params.
type IPFS_ls_Params_List = capnp.StructList[IPFS_ls_Params]

// NewIPFS_ls_Params creates a new list of IPFS_ls_Params.
func NewIPFS_ls_Params_List(s *capnp.Segment, sz int32) (IPFS_ls_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_ls_Params](l), err
}

// IPFS_ls_Params_Future is a wrapper for a IPFS_ls_Params promised by a client call.
type IPFS_ls_Params_Future struct{ *capnp.Future }

func (f IPFS_ls_Params_Future) Struct() (IPFS_ls_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_ls_Params(p.Struct()), err
}

type IPFS_ls_Results capnp.Struct

// IPFS_ls_Results_TypeID is the unique identifier for the type IPFS_ls_Results.
const IPFS_ls_Results_TypeID = 0xc65336464e949b9c

func NewIPFS_ls_Results(s *capnp.Segment) (IPFS_ls_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_ls_Results(st), err
}

func NewRootIPFS_ls_Results(s *capnp.Segment) (IPFS_ls_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_ls_Results(st), err
}

func ReadRootIPFS_ls_Results(msg *capnp.Message) (IPFS_ls_Results, error) {
	root, err := msg.Root()
	return IPFS_ls_Results(root.Struct()), err
}

func (s IPFS_ls_Results) String() string {
	str, _ := text.Marshal(0xc65336464e949b9c, capnp.Struct(s))
	return str
}

func (s IPFS_ls_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_ls_Results) DecodeFromPtr(p capnp.Ptr) IPFS_ls_Results {
	return IPFS_ls_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_ls_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_ls_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_ls_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_ls_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_ls_Results) Entries() (Entry_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Entry_List(p.List()), err
}

func (s IPFS_ls_Results) HasEntries() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_ls_Results) SetEntries(v Entry_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewEntries sets the entries field to a newly
// allocated Entry_List, preferring placement in s's segment.
func (s IPFS_ls_Results) NewEntries(n int32) (Entry_List, error) {
	l, err := NewEntry_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Entry_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// IPFS_ls_Results_List is a list of IPFS_ls_Results.
type IPFS_ls_Results_List = capnp.StructList[IPFS_ls_Results]

// NewIPFS_ls_Results creates a new list of IPFS_ls_Results.
func NewIPFS_ls_Results_List(s *capnp.Segment, sz int32) (IPFS_ls_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_ls_Results](l), err
}

// IPFS_ls_Results_Future is a wrapper for a IPFS_ls_Results promised by a client call.
type IPFS_ls_Results_Future struct{ *capnp.Future }

func (f IPFS_ls_Results_Future) Struct() (IPFS_ls_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_ls_Results(p.Struct()), err
}

type IPFS_stat_Params capnp.Struct

// IPFS_stat_Params_TypeID is the unique identifier for the type IPFS_stat_Params.
const IPFS_stat_Params_TypeID = 0x8284348c17041a84

func NewIPFS_stat_Params(s *capnp.Segment) (IPFS_stat_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_stat_Params(st), err
}

func NewRootIPFS_stat_Params(s *capnp.Segment) (IPFS_stat_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_stat_Params(st), err
}

func ReadRootIPFS_stat_Params(msg *capnp.Message) (IPFS_stat_Params, error) {
	root, err := msg.Root()
	return IPFS_stat_Params(root.Struct()), err
}

func (s IPFS_stat_Params) String() string {
	str, _ := text.Marshal(0x8284348c17041a84, capnp.Struct(s))
	return str
}

func (s IPFS_stat_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_stat_Params) DecodeFromPtr(p capnp.Ptr) IPFS_stat_Params {
	return IPFS_stat_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_stat_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_stat_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_stat_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_stat_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_stat_Params) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_stat_Params) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_stat_Params) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_stat_Params) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_stat_Params_List is a list of IPFS_stat_Params.
type IPFS_stat_Params_List = capnp.StructList[IPFS_stat_Params]

// NewIPFS_stat_Params creates a new list of IPFS_stat_Params.
func NewIPFS_stat_Params_List(s *capnp.Segment, sz int32) (IPFS_stat_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_stat_Params](l), err
}

// IPFS_stat_Params_Future is a wrapper for a IPFS_stat_Params promised by a client call.
type IPFS_stat_Params_Future struct{ *capnp.Future }

func (f IPFS_stat_Params_Future) Struct() (IPFS_stat_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_stat_Params(p.Struct()), err
}

type IPFS_stat_Results capnp.Struct

// IPFS_stat_Results_TypeID is the unique identifier for the type IPFS_stat_Results.
const IPFS_stat_Results_TypeID = 0x90338670b754f0d0

func NewIPFS_stat_Results(s *capnp.Segment) (IPFS_stat_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_stat_Results(st), err
}

func NewRootIPFS_stat_Results(s *capnp.Segment) (IPFS_stat_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_stat_Results(st), err
}

func ReadRootIPFS_stat_Results(msg *capnp.Message) (IPFS_stat_Results, error) {
	root, err := msg.Root()
	return IPFS_stat_Results(root.Struct()), err
}

func (s IPFS_stat_Results) String() string {
	str, _ := text.Marshal(0x90338670b754f0d0, capnp.Struct(s))
	return str
}

func (s IPFS_stat_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_stat_Results) DecodeFromPtr(p capnp.Ptr) IPFS_stat_Results {
	return IPFS_stat_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_stat_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_stat_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_stat_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_stat_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_stat_Results) Info() (NodeInfo, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return NodeInfo(p.Struct()), err
}

func (s IPFS_stat_Results) HasInfo() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_stat_Results) SetInfo(v NodeInfo) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewInfo sets the info field to a newly
// allocated NodeInfo struct, preferring placement in s's segment.
func (s IPFS_stat_Results) NewInfo() (NodeInfo, error) {
	ss, err := NewNodeInfo(capnp.Struct(s).Segment())
	if err != nil {
		return NodeInfo{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// IPFS_stat_Results_List is a list of IPFS_stat_Results.
type IPFS_stat_Results_List = capnp.StructList[IPFS_stat_Results]

// NewIPFS_stat_Results creates a new list of IPFS_stat_Results.
func NewIPFS_stat_Results_List(s *capnp.Segment, sz int32) (IPFS_stat_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_stat_Results](l), err
}

// IPFS_stat_Results_Future is a wrapper for a IPFS_stat_Results promised by a client call.
type IPFS_stat_Results_Future struct{ *capnp.Future }

func (f IPFS_stat_Results_Future) Struct() (IPFS_stat_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_stat_Results(p.Struct()), err
}
func (p IPFS_stat_Results_Future) Info() NodeInfo_Future {
	return NodeInfo_Future{Future: p.Future.Field(0, nil)}
}

type IPFS_pin_Params capnp.Struct

// IPFS_pin_Params_TypeID is the unique identifier for the type IPFS_pin_Params.
const IPFS_pin_Params_TypeID = 0xba93d5e4aea44e63

func NewIPFS_pin_Params(s *capnp.Segment) (IPFS_pin_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_pin_Params(st), err
}

func NewRootIPFS_pin_Params(s *capnp.Segment) (IPFS_pin_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_pin_Params(st), err
}

func ReadRootIPFS_pin_Params(msg *capnp.Message) (IPFS_pin_Params, error) {
	root, err := msg.Root()
	return IPFS_pin_Params(root.Struct()), err
}

func (s IPFS_pin_Params) String() string {
	str, _ := text.Marshal(0xba93d5e4aea44e63, capnp.Struct(s))
	return str
}

func (s IPFS_pin_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_pin_Params) DecodeFromPtr(p capnp.Ptr) IPFS_pin_Params {
	return IPFS_pin_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_pin_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_pin_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_pin_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_pin_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_pin_Params) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_pin_Params) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_pin_Params) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_pin_Params) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_pin_Params_List is a list of IPFS_pin_Params.
type IPFS_pin_Params_List = capnp.StructList[IPFS_pin_Params]

// NewIPFS_pin_Params creates a new list of IPFS_pin_Params.
func NewIPFS_pin_Params_List(s *capnp.Segment, sz int32) (IPFS_pin_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_pin_Params](l), err
}

// IPFS_pin_Params_Future is a wrapper for a IPFS_pin_Params promised by a client call.
type IPFS_pin_Params_Future struct{ *capnp.Future }

func (f IPFS_pin_Params_Future) Struct() (IPFS_pin_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_pin_Params(p.Struct()), err
}

type IPFS_pin_Results capnp.Struct

// IPFS_pin_Results_TypeID is the unique identifier for the type IPFS_pin_Results.
const IPFS_pin_Results_TypeID = 0xf81b3789a4d0575d

func NewIPFS_pin_Results(s *capnp.Segment) (IPFS_pin_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_pin_Results(st), err
}

func NewRootIPFS_pin_Results(s *capnp.Segment) (IPFS_pin_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_pin_Results(st), err
}

func ReadRootIPFS_pin_Results(msg *capnp.Message) (IPFS_pin_Results, error) {
	root, err := msg.Root()
	return IPFS_pin_Results(root.Struct()), err
}

func (s IPFS_pin_Results) String() string {
	str, _ := text.Marshal(0xf81b3789a4d0575d, capnp.Struct(s))
	return str
}

func (s IPFS_pin_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_pin_Results) DecodeFromPtr(p capnp.Ptr) IPFS_pin_Results {
	return IPFS_pin_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_pin_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_pin_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_pin_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_pin_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_pin_Results) Success() bool {
	return capnp.Struct(s).Bit(0)
}

func (s IPFS_pin_Results) SetSuccess(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

// IPFS_pin_Results_List is a list of IPFS_pin_Results.
type IPFS_pin_Results_List = capnp.StructList[IPFS_pin_Results]

// NewIPFS_pin_Results creates a new list of IPFS_pin_Results.
func NewIPFS_pin_Results_List(s *capnp.Segment, sz int32) (IPFS_pin_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_pin_Results](l), err
}

// IPFS_pin_Results_Future is a wrapper for a IPFS_pin_Results promised by a client call.
type IPFS_pin_Results_Future struct{ *capnp.Future }

func (f IPFS_pin_Results_Future) Struct() (IPFS_pin_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_pin_Results(p.Struct()), err
}

type IPFS_unpin_Params capnp.Struct

// IPFS_unpin_Params_TypeID is the unique identifier for the type IPFS_unpin_Params.
const IPFS_unpin_Params_TypeID = 0x8c76ad0fbaea12d7

func NewIPFS_unpin_Params(s *capnp.Segment) (IPFS_unpin_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_unpin_Params(st), err
}

func NewRootIPFS_unpin_Params(s *capnp.Segment) (IPFS_unpin_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_unpin_Params(st), err
}

func ReadRootIPFS_unpin_Params(msg *capnp.Message) (IPFS_unpin_Params, error) {
	root, err := msg.Root()
	return IPFS_unpin_Params(root.Struct()), err
}

func (s IPFS_unpin_Params) String() string {
	str, _ := text.Marshal(0x8c76ad0fbaea12d7, capnp.Struct(s))
	return str
}

func (s IPFS_unpin_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_unpin_Params) DecodeFromPtr(p capnp.Ptr) IPFS_unpin_Params {
	return IPFS_unpin_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_unpin_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_unpin_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_unpin_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_unpin_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_unpin_Params) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_unpin_Params) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_unpin_Params) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_unpin_Params) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_unpin_Params_List is a list of IPFS_unpin_Params.
type IPFS_unpin_Params_List = capnp.StructList[IPFS_unpin_Params]

// NewIPFS_unpin_Params creates a new list of IPFS_unpin_Params.
func NewIPFS_unpin_Params_List(s *capnp.Segment, sz int32) (IPFS_unpin_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_unpin_Params](l), err
}

// IPFS_unpin_Params_Future is a wrapper for a IPFS_unpin_Params promised by a client call.
type IPFS_unpin_Params_Future struct{ *capnp.Future }

func (f IPFS_unpin_Params_Future) Struct() (IPFS_unpin_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_unpin_Params(p.Struct()), err
}

type IPFS_unpin_Results capnp.Struct

// IPFS_unpin_Results_TypeID is the unique identifier for the type IPFS_unpin_Results.
const IPFS_unpin_Results_TypeID = 0xa72dee615d5bbb87

func NewIPFS_unpin_Results(s *capnp.Segment) (IPFS_unpin_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_unpin_Results(st), err
}

func NewRootIPFS_unpin_Results(s *capnp.Segment) (IPFS_unpin_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_unpin_Results(st), err
}

func ReadRootIPFS_unpin_Results(msg *capnp.Message) (IPFS_unpin_Results, error) {
	root, err := msg.Root()
	return IPFS_unpin_Results(root.Struct()), err
}

func (s IPFS_unpin_Results) String() string {
	str, _ := text.Marshal(0xa72dee615d5bbb87, capnp.Struct(s))
	return str
}

func (s IPFS_unpin_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_unpin_Results) DecodeFromPtr(p capnp.Ptr) IPFS_unpin_Results {
	return IPFS_unpin_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_unpin_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_unpin_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_unpin_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_unpin_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_unpin_Results) Success() bool {
	return capnp.Struct(s).Bit(0)
}

func (s IPFS_unpin_Results) SetSuccess(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

// IPFS_unpin_Results_List is a list of IPFS_unpin_Results.
type IPFS_unpin_Results_List = capnp.StructList[IPFS_unpin_Results]

// NewIPFS_unpin_Results creates a new list of IPFS_unpin_Results.
func NewIPFS_unpin_Results_List(s *capnp.Segment, sz int32) (IPFS_unpin_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_unpin_Results](l), err
}

// IPFS_unpin_Results_Future is a wrapper for a IPFS_unpin_Results promised by a client call.
type IPFS_unpin_Results_Future struct{ *capnp.Future }

func (f IPFS_unpin_Results_Future) Struct() (IPFS_unpin_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_unpin_Results(p.Struct()), err
}

type IPFS_pins_Params capnp.Struct

// IPFS_pins_Params_TypeID is the unique identifier for the type IPFS_pins_Params.
const IPFS_pins_Params_TypeID = 0xe798bea7bc0cc0ea

func NewIPFS_pins_Params(s *capnp.Segment) (IPFS_pins_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_pins_Params(st), err
}

func NewRootIPFS_pins_Params(s *capnp.Segment) (IPFS_pins_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_pins_Params(st), err
}

func ReadRootIPFS_pins_Params(msg *capnp.Message) (IPFS_pins_Params, error) {
	root, err := msg.Root()
	return IPFS_pins_Params(root.Struct()), err
}

func (s IPFS_pins_Params) String() string {
	str, _ := text.Marshal(0xe798bea7bc0cc0ea, capnp.Struct(s))
	return str
}

func (s IPFS_pins_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_pins_Params) DecodeFromPtr(p capnp.Ptr) IPFS_pins_Params {
	return IPFS_pins_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_pins_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_pins_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_pins_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_pins_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// IPFS_pins_Params_List is a list of IPFS_pins_Params.
type IPFS_pins_Params_List = capnp.StructList[IPFS_pins_Params]

// NewIPFS_pins_Params creates a new list of IPFS_pins_Params.
func NewIPFS_pins_Params_List(s *capnp.Segment, sz int32) (IPFS_pins_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_pins_Params](l), err
}

// IPFS_pins_Params_Future is a wrapper for a IPFS_pins_Params promised by a client call.
type IPFS_pins_Params_Future struct{ *capnp.Future }

func (f IPFS_pins_Params_Future) Struct() (IPFS_pins_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_pins_Params(p.Struct()), err
}

type IPFS_pins_Results capnp.Struct

// IPFS_pins_Results_TypeID is the unique identifier for the type IPFS_pins_Results.
const IPFS_pins_Results_TypeID = 0xe0f22a608a7c6e22

func NewIPFS_pins_Results(s *capnp.Segment) (IPFS_pins_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_pins_Results(st), err
}

func NewRootIPFS_pins_Results(s *capnp.Segment) (IPFS_pins_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_pins_Results(st), err
}

func ReadRootIPFS_pins_Results(msg *capnp.Message) (IPFS_pins_Results, error) {
	root, err := msg.Root()
	return IPFS_pins_Results(root.Struct()), err
}

func (s IPFS_pins_Results) String() string {
	str, _ := text.Marshal(0xe0f22a608a7c6e22, capnp.Struct(s))
	return str
}

func (s IPFS_pins_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_pins_Results) DecodeFromPtr(p capnp.Ptr) IPFS_pins_Results {
	return IPFS_pins_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_pins_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_pins_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_pins_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_pins_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_pins_Results) Cids() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s IPFS_pins_Results) HasCids() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_pins_Results) SetCids(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewCids sets the cids field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s IPFS_pins_Results) NewCids(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// IPFS_pins_Results_List is a list of IPFS_pins_Results.
type IPFS_pins_Results_List = capnp.StructList[IPFS_pins_Results]

// NewIPFS_pins_Results creates a new list of IPFS_pins_Results.
func NewIPFS_pins_Results_List(s *capnp.Segment, sz int32) (IPFS_pins_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_pins_Results](l), err
}

// IPFS_pins_Results_Future is a wrapper for a IPFS_pins_Results promised by a client call.
type IPFS_pins_Results_Future struct{ *capnp.Future }

func (f IPFS_pins_Results_Future) Struct() (IPFS_pins_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_pins_Results(p.Struct()), err
}

type IPFS_id_Params capnp.Struct

// IPFS_id_Params_TypeID is the unique identifier for the type IPFS_id_Params.
const IPFS_id_Params_TypeID = 0xb7e699451c43a067

func NewIPFS_id_Params(s *capnp.Segment) (IPFS_id_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_id_Params(st), err
}

func NewRootIPFS_id_Params(s *capnp.Segment) (IPFS_id_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_id_Params(st), err
}

func ReadRootIPFS_id_Params(msg *capnp.Message) (IPFS_id_Params, error) {
	root, err := msg.Root()
	return IPFS_id_Params(root.Struct()), err
}

func (s IPFS_id_Params) String() string {
	str, _ := text.Marshal(0xb7e699451c43a067, capnp.Struct(s))
	return str
}

func (s IPFS_id_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_id_Params) DecodeFromPtr(p capnp.Ptr) IPFS_id_Params {
	return IPFS_id_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_id_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_id_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_id_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_id_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// IPFS_id_Params_List is a list of IPFS_id_Params.
type IPFS_id_Params_List = capnp.StructList[IPFS_id_Params]

// NewIPFS_id_Params creates a new list of IPFS_id_Params.
func NewIPFS_id_Params_List(s *capnp.Segment, sz int32) (IPFS_id_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_id_Params](l), err
}

// IPFS_id_Params_Future is a wrapper for a IPFS_id_Params promised by a client call.
type IPFS_id_Params_Future struct{ *capnp.Future }

func (f IPFS_id_Params_Future) Struct() (IPFS_id_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_id_Params(p.Struct()), err
}

type IPFS_id_Results capnp.Struct

// IPFS_id_Results_TypeID is the unique identifier for the type IPFS_id_Results.
const IPFS_id_Results_TypeID = 0xf469f437c0bfc104

func NewIPFS_id_Results(s *capnp.Segment) (IPFS_id_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_id_Results(st), err
}

func NewRootIPFS_id_Results(s *capnp.Segment) (IPFS_id_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_id_Results(st), err
}

func ReadRootIPFS_id_Results(msg *capnp.Message) (IPFS_id_Results, error) {
	root, err := msg.Root()
	return IPFS_id_Results(root.Struct()), err
}

func (s IPFS_id_Results) String() string {
	str, _ := text.Marshal(0xf469f437c0bfc104, capnp.Struct(s))
	return str
}

func (s IPFS_id_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_id_Results) DecodeFromPtr(p capnp.Ptr) IPFS_id_Results {
	return IPFS_id_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_id_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_id_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_id_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_id_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_id_Results) PeerInfo() (PeerInfo, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return PeerInfo(p.Struct()), err
}

func (s IPFS_id_Results) HasPeerInfo() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_id_Results) SetPeerInfo(v PeerInfo) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewPeerInfo sets the peerInfo field to a newly
// allocated PeerInfo struct, preferring placement in s's segment.
func (s IPFS_id_Results) NewPeerInfo() (PeerInfo, error) {
	ss, err := NewPeerInfo(capnp.Struct(s).Segment())
	if err != nil {
		return PeerInfo{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// IPFS_id_Results_List is a list of IPFS_id_Results.
type IPFS_id_Results_List = capnp.StructList[IPFS_id_Results]

// NewIPFS_id_Results creates a new list of IPFS_id_Results.
func NewIPFS_id_Results_List(s *capnp.Segment, sz int32) (IPFS_id_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_id_Results](l), err
}

// IPFS_id_Results_Future is a wrapper for a IPFS_id_Results promised by a client call.
type IPFS_id_Results_Future struct{ *capnp.Future }

func (f IPFS_id_Results_Future) Struct() (IPFS_id_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_id_Results(p.Struct()), err
}
func (p IPFS_id_Results_Future) PeerInfo() PeerInfo_Future {
	return PeerInfo_Future{Future: p.Future.Field(0, nil)}
}

type IPFS_connect_Params capnp.Struct

// IPFS_connect_Params_TypeID is the unique identifier for the type IPFS_connect_Params.
const IPFS_connect_Params_TypeID = 0xadae6334690b6b6f

func NewIPFS_connect_Params(s *capnp.Segment) (IPFS_connect_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_connect_Params(st), err
}

func NewRootIPFS_connect_Params(s *capnp.Segment) (IPFS_connect_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_connect_Params(st), err
}

func ReadRootIPFS_connect_Params(msg *capnp.Message) (IPFS_connect_Params, error) {
	root, err := msg.Root()
	return IPFS_connect_Params(root.Struct()), err
}

func (s IPFS_connect_Params) String() string {
	str, _ := text.Marshal(0xadae6334690b6b6f, capnp.Struct(s))
	return str
}

func (s IPFS_connect_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_connect_Params) DecodeFromPtr(p capnp.Ptr) IPFS_connect_Params {
	return IPFS_connect_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_connect_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_connect_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_connect_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_connect_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_connect_Params) Addr() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_connect_Params) HasAddr() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_connect_Params) AddrBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_connect_Params) SetAddr(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_connect_Params_List is a list of IPFS_connect_Params.
type IPFS_connect_Params_List = capnp.StructList[IPFS_connect_Params]

// NewIPFS_connect_Params creates a new list of IPFS_connect_Params.
func NewIPFS_connect_Params_List(s *capnp.Segment, sz int32) (IPFS_connect_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_connect_Params](l), err
}

// IPFS_connect_Params_Future is a wrapper for a IPFS_connect_Params promised by a client call.
type IPFS_connect_Params_Future struct{ *capnp.Future }

func (f IPFS_connect_Params_Future) Struct() (IPFS_connect_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_connect_Params(p.Struct()), err
}

type IPFS_connect_Results capnp.Struct

// IPFS_connect_Results_TypeID is the unique identifier for the type IPFS_connect_Results.
const IPFS_connect_Results_TypeID = 0xc5fe3a2c8650ed19

func NewIPFS_connect_Results(s *capnp.Segment) (IPFS_connect_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_connect_Results(st), err
}

func NewRootIPFS_connect_Results(s *capnp.Segment) (IPFS_connect_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_connect_Results(st), err
}

func ReadRootIPFS_connect_Results(msg *capnp.Message) (IPFS_connect_Results, error) {
	root, err := msg.Root()
	return IPFS_connect_Results(root.Struct()), err
}

func (s IPFS_connect_Results) String() string {
	str, _ := text.Marshal(0xc5fe3a2c8650ed19, capnp.Struct(s))
	return str
}

func (s IPFS_connect_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_connect_Results) DecodeFromPtr(p capnp.Ptr) IPFS_connect_Results {
	return IPFS_connect_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_connect_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_connect_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_connect_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_connect_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_connect_Results) Success() bool {
	return capnp.Struct(s).Bit(0)
}

func (s IPFS_connect_Results) SetSuccess(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

// IPFS_connect_Results_List is a list of IPFS_connect_Results.
type IPFS_connect_Results_List = capnp.StructList[IPFS_connect_Results]

// NewIPFS_connect_Results creates a new list of IPFS_connect_Results.
func NewIPFS_connect_Results_List(s *capnp.Segment, sz int32) (IPFS_connect_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_connect_Results](l), err
}

// IPFS_connect_Results_Future is a wrapper for a IPFS_connect_Results promised by a client call.
type IPFS_connect_Results_Future struct{ *capnp.Future }

func (f IPFS_connect_Results_Future) Struct() (IPFS_connect_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_connect_Results(p.Struct()), err
}

type IPFS_peers_Params capnp.Struct

// IPFS_peers_Params_TypeID is the unique identifier for the type IPFS_peers_Params.
const IPFS_peers_Params_TypeID = 0xdbc8c8183207fc9c

func NewIPFS_peers_Params(s *capnp.Segment) (IPFS_peers_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_peers_Params(st), err
}

func NewRootIPFS_peers_Params(s *capnp.Segment) (IPFS_peers_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_peers_Params(st), err
}

func ReadRootIPFS_peers_Params(msg *capnp.Message) (IPFS_peers_Params, error) {
	root, err := msg.Root()
	return IPFS_peers_Params(root.Struct()), err
}

func (s IPFS_peers_Params) String() string {
	str, _ := text.Marshal(0xdbc8c8183207fc9c, capnp.Struct(s))
	return str
}

func (s IPFS_peers_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_peers_Params) DecodeFromPtr(p capnp.Ptr) IPFS_peers_Params {
	return IPFS_peers_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_peers_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_peers_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_peers_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_peers_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// IPFS_peers_Params_List is a list of IPFS_peers_Params.
type IPFS_peers_Params_List = capnp.StructList[IPFS_peers_Params]

// NewIPFS_peers_Params creates a new list of IPFS_peers_Params.
func NewIPFS_peers_Params_List(s *capnp.Segment, sz int32) (IPFS_peers_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_peers_Params](l), err
}

// IPFS_peers_Params_Future is a wrapper for a IPFS_peers_Params promised by a client call.
type IPFS_peers_Params_Future struct{ *capnp.Future }

func (f IPFS_peers_Params_Future) Struct() (IPFS_peers_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_peers_Params(p.Struct()), err
}

type IPFS_peers_Results capnp.Struct

// IPFS_peers_Results_TypeID is the unique identifier for the type IPFS_peers_Results.
const IPFS_peers_Results_TypeID = 0x8e86d1c015472327

func NewIPFS_peers_Results(s *capnp.Segment) (IPFS_peers_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_peers_Results(st), err
}

func NewRootIPFS_peers_Results(s *capnp.Segment) (IPFS_peers_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_peers_Results(st), err
}

func ReadRootIPFS_peers_Results(msg *capnp.Message) (IPFS_peers_Results, error) {
	root, err := msg.Root()
	return IPFS_peers_Results(root.Struct()), err
}

func (s IPFS_peers_Results) String() string {
	str, _ := text.Marshal(0x8e86d1c015472327, capnp.Struct(s))
	return str
}

func (s IPFS_peers_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_peers_Results) DecodeFromPtr(p capnp.Ptr) IPFS_peers_Results {
	return IPFS_peers_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_peers_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_peers_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_peers_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_peers_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_peers_Results) PeerList() (PeerInfo_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return PeerInfo_List(p.List()), err
}

func (s IPFS_peers_Results) HasPeerList() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_peers_Results) SetPeerList(v PeerInfo_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewPeerList sets the peerList field to a newly
// allocated PeerInfo_List, preferring placement in s's segment.
func (s IPFS_peers_Results) NewPeerList(n int32) (PeerInfo_List, error) {
	l, err := NewPeerInfo_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return PeerInfo_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// IPFS_peers_Results_List is a list of IPFS_peers_Results.
type IPFS_peers_Results_List = capnp.StructList[IPFS_peers_Results]

// NewIPFS_peers_Results creates a new list of IPFS_peers_Results.
func NewIPFS_peers_Results_List(s *capnp.Segment, sz int32) (IPFS_peers_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_peers_Results](l), err
}

// IPFS_peers_Results_Future is a wrapper for a IPFS_peers_Results promised by a client call.
type IPFS_peers_Results_Future struct{ *capnp.Future }

func (f IPFS_peers_Results_Future) Struct() (IPFS_peers_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_peers_Results(p.Struct()), err
}

type IPFS_resolveNode_Params capnp.Struct

// IPFS_resolveNode_Params_TypeID is the unique identifier for the type IPFS_resolveNode_Params.
const IPFS_resolveNode_Params_TypeID = 0x9cf72e44358fe4b0

func NewIPFS_resolveNode_Params(s *capnp.Segment) (IPFS_resolveNode_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_resolveNode_Params(st), err
}

func NewRootIPFS_resolveNode_Params(s *capnp.Segment) (IPFS_resolveNode_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_resolveNode_Params(st), err
}

func ReadRootIPFS_resolveNode_Params(msg *capnp.Message) (IPFS_resolveNode_Params, error) {
	root, err := msg.Root()
	return IPFS_resolveNode_Params(root.Struct()), err
}

func (s IPFS_resolveNode_Params) String() string {
	str, _ := text.Marshal(0x9cf72e44358fe4b0, capnp.Struct(s))
	return str
}

func (s IPFS_resolveNode_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_resolveNode_Params) DecodeFromPtr(p capnp.Ptr) IPFS_resolveNode_Params {
	return IPFS_resolveNode_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_resolveNode_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_resolveNode_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_resolveNode_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_resolveNode_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_resolveNode_Params) Path() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_resolveNode_Params) HasPath() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_resolveNode_Params) PathBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_resolveNode_Params) SetPath(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_resolveNode_Params_List is a list of IPFS_resolveNode_Params.
type IPFS_resolveNode_Params_List = capnp.StructList[IPFS_resolveNode_Params]

// NewIPFS_resolveNode_Params creates a new list of IPFS_resolveNode_Params.
func NewIPFS_resolveNode_Params_List(s *capnp.Segment, sz int32) (IPFS_resolveNode_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_resolveNode_Params](l), err
}

// IPFS_resolveNode_Params_Future is a wrapper for a IPFS_resolveNode_Params promised by a client call.
type IPFS_resolveNode_Params_Future struct{ *capnp.Future }

func (f IPFS_resolveNode_Params_Future) Struct() (IPFS_resolveNode_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_resolveNode_Params(p.Struct()), err
}

type IPFS_resolveNode_Results capnp.Struct

// IPFS_resolveNode_Results_TypeID is the unique identifier for the type IPFS_resolveNode_Results.
const IPFS_resolveNode_Results_TypeID = 0xc2a16bbf01ada632

func NewIPFS_resolveNode_Results(s *capnp.Segment) (IPFS_resolveNode_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return IPFS_resolveNode_Results(st), err
}

func NewRootIPFS_resolveNode_Results(s *capnp.Segment) (IPFS_resolveNode_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return IPFS_resolveNode_Results(st), err
}

func ReadRootIPFS_resolveNode_Results(msg *capnp.Message) (IPFS_resolveNode_Results, error) {
	root, err := msg.Root()
	return IPFS_resolveNode_Results(root.Struct()), err
}

func (s IPFS_resolveNode_Results) String() string {
	str, _ := text.Marshal(0xc2a16bbf01ada632, capnp.Struct(s))
	return str
}

func (s IPFS_resolveNode_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_resolveNode_Results) DecodeFromPtr(p capnp.Ptr) IPFS_resolveNode_Results {
	return IPFS_resolveNode_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_resolveNode_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_resolveNode_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_resolveNode_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_resolveNode_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_resolveNode_Results) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_resolveNode_Results) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_resolveNode_Results) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_resolveNode_Results) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s IPFS_resolveNode_Results) Node() anchor.Node {
	p, _ := capnp.Struct(s).Ptr(1)
	return anchor.Node(p.Interface().Client())
}

func (s IPFS_resolveNode_Results) HasNode() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s IPFS_resolveNode_Results) SetNode(v anchor.Node) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(1, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(1, in.ToPtr())
}

// IPFS_resolveNode_Results_List is a list of IPFS_resolveNode_Results.
type IPFS_resolveNode_Results_List = capnp.StructList[IPFS_resolveNode_Results]

// NewIPFS_resolveNode_Results creates a new list of IPFS_resolveNode_Results.
func NewIPFS_resolveNode_Results_List(s *capnp.Segment, sz int32) (IPFS_resolveNode_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[IPFS_resolveNode_Results](l), err
}

// IPFS_resolveNode_Results_Future is a wrapper for a IPFS_resolveNode_Results promised by a client call.
type IPFS_resolveNode_Results_Future struct{ *capnp.Future }

func (f IPFS_resolveNode_Results_Future) Struct() (IPFS_resolveNode_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_resolveNode_Results(p.Struct()), err
}
func (p IPFS_resolveNode_Results_Future) Node() anchor.Node {
	return anchor.Node(p.Future.Field(1, nil).Client())
}

type Entry capnp.Struct

// Entry_TypeID is the unique identifier for the type Entry.
const Entry_TypeID = 0xe50956368ed67ecf

func NewEntry(s *capnp.Segment) (Entry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Entry(st), err
}

func NewRootEntry(s *capnp.Segment) (Entry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Entry(st), err
}

func ReadRootEntry(msg *capnp.Message) (Entry, error) {
	root, err := msg.Root()
	return Entry(root.Struct()), err
}

func (s Entry) String() string {
	str, _ := text.Marshal(0xe50956368ed67ecf, capnp.Struct(s))
	return str
}

func (s Entry) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Entry) DecodeFromPtr(p capnp.Ptr) Entry {
	return Entry(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Entry) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Entry) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Entry) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Entry) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Entry) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Entry) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Entry) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Entry) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Entry) Type() EntryType {
	return EntryType(capnp.Struct(s).Uint16(0))
}

func (s Entry) SetType(v EntryType) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Entry) Size() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s Entry) SetSize(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s Entry) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Entry) HasCid() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Entry) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Entry) SetCid(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Entry_List is a list of Entry.
type Entry_List = capnp.StructList[Entry]

// NewEntry creates a new list of Entry.
func NewEntry_List(s *capnp.Segment, sz int32) (Entry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Entry](l), err
}

// Entry_Future is a wrapper for a Entry promised by a client call.
type Entry_Future struct{ *capnp.Future }

func (f Entry_Future) Struct() (Entry, error) {
	p, err := f.Future.Ptr()
	return Entry(p.Struct()), err
}

type EntryType uint16

// EntryType_TypeID is the unique identifier for the type EntryType.
const EntryType_TypeID = 0x84f03db984574d8a

// Values of EntryType.
const (
	EntryType_file      EntryType = 0
	EntryType_directory EntryType = 1
	EntryType_symlink   EntryType = 2
)

// String returns the enum's constant name.
func (c EntryType) String() string {
	switch c {
	case EntryType_file:
		return "file"
	case EntryType_directory:
		return "directory"
	case EntryType_symlink:
		return "symlink"

	default:
		return ""
	}
}

// EntryTypeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func EntryTypeFromString(c string) EntryType {
	switch c {
	case "file":
		return EntryType_file
	case "directory":
		return EntryType_directory
	case "symlink":
		return EntryType_symlink

	default:
		return 0
	}
}

type EntryType_List = capnp.EnumList[EntryType]

func NewEntryType_List(s *capnp.Segment, sz int32) (EntryType_List, error) {
	return capnp.NewEnumList[EntryType](s, sz)
}

type NodeInfo capnp.Struct
type NodeInfo_nodeType NodeInfo
type NodeInfo_nodeType_Which uint16

const (
	NodeInfo_nodeType_Which_file      NodeInfo_nodeType_Which = 0
	NodeInfo_nodeType_Which_directory NodeInfo_nodeType_Which = 1
	NodeInfo_nodeType_Which_symlink   NodeInfo_nodeType_Which = 2
)

func (w NodeInfo_nodeType_Which) String() string {
	const s = "filedirectorysymlink"
	switch w {
	case NodeInfo_nodeType_Which_file:
		return s[0:4]
	case NodeInfo_nodeType_Which_directory:
		return s[4:13]
	case NodeInfo_nodeType_Which_symlink:
		return s[13:20]

	}
	return "NodeInfo_nodeType_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// NodeInfo_TypeID is the unique identifier for the type NodeInfo.
const NodeInfo_TypeID = 0xa83fd4abe6553705

func NewNodeInfo(s *capnp.Segment) (NodeInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return NodeInfo(st), err
}

func NewRootNodeInfo(s *capnp.Segment) (NodeInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2})
	return NodeInfo(st), err
}

func ReadRootNodeInfo(msg *capnp.Message) (NodeInfo, error) {
	root, err := msg.Root()
	return NodeInfo(root.Struct()), err
}

func (s NodeInfo) String() string {
	str, _ := text.Marshal(0xa83fd4abe6553705, capnp.Struct(s))
	return str
}

func (s NodeInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (NodeInfo) DecodeFromPtr(p capnp.Ptr) NodeInfo {
	return NodeInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s NodeInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s NodeInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s NodeInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s NodeInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s NodeInfo) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s NodeInfo) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s NodeInfo) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s NodeInfo) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s NodeInfo) Size() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s NodeInfo) SetSize(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s NodeInfo) CumulativeSize() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s NodeInfo) SetCumulativeSize(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s NodeInfo) NodeType() NodeInfo_nodeType { return NodeInfo_nodeType(s) }

func (s NodeInfo_nodeType) Which() NodeInfo_nodeType_Which {
	return NodeInfo_nodeType_Which(capnp.Struct(s).Uint16(16))
}
func (s NodeInfo_nodeType) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s NodeInfo_nodeType) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s NodeInfo_nodeType) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s NodeInfo_nodeType) File() (FileInfo, error) {
	if capnp.Struct(s).Uint16(16) != 0 {
		panic("Which() != file")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return FileInfo(p.Struct()), err
}

func (s NodeInfo_nodeType) HasFile() bool {
	if capnp.Struct(s).Uint16(16) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s NodeInfo_nodeType) SetFile(v FileInfo) error {
	capnp.Struct(s).SetUint16(16, 0)
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewFile sets the file field to a newly
// allocated FileInfo struct, preferring placement in s's segment.
func (s NodeInfo_nodeType) NewFile() (FileInfo, error) {
	capnp.Struct(s).SetUint16(16, 0)
	ss, err := NewFileInfo(capnp.Struct(s).Segment())
	if err != nil {
		return FileInfo{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s NodeInfo_nodeType) Directory() (DirectoryInfo, error) {
	if capnp.Struct(s).Uint16(16) != 1 {
		panic("Which() != directory")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return DirectoryInfo(p.Struct()), err
}

func (s NodeInfo_nodeType) HasDirectory() bool {
	if capnp.Struct(s).Uint16(16) != 1 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s NodeInfo_nodeType) SetDirectory(v DirectoryInfo) error {
	capnp.Struct(s).SetUint16(16, 1)
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewDirectory sets the directory field to a newly
// allocated DirectoryInfo struct, preferring placement in s's segment.
func (s NodeInfo_nodeType) NewDirectory() (DirectoryInfo, error) {
	capnp.Struct(s).SetUint16(16, 1)
	ss, err := NewDirectoryInfo(capnp.Struct(s).Segment())
	if err != nil {
		return DirectoryInfo{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s NodeInfo_nodeType) Symlink() (SymlinkInfo, error) {
	if capnp.Struct(s).Uint16(16) != 2 {
		panic("Which() != symlink")
	}
	p, err := capnp.Struct(s).Ptr(1)
	return SymlinkInfo(p.Struct()), err
}

func (s NodeInfo_nodeType) HasSymlink() bool {
	if capnp.Struct(s).Uint16(16) != 2 {
		return false
	}
	return capnp.Struct(s).HasPtr(1)
}

func (s NodeInfo_nodeType) SetSymlink(v SymlinkInfo) error {
	capnp.Struct(s).SetUint16(16, 2)
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewSymlink sets the symlink field to a newly
// allocated SymlinkInfo struct, preferring placement in s's segment.
func (s NodeInfo_nodeType) NewSymlink() (SymlinkInfo, error) {
	capnp.Struct(s).SetUint16(16, 2)
	ss, err := NewSymlinkInfo(capnp.Struct(s).Segment())
	if err != nil {
		return SymlinkInfo{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// NodeInfo_List is a list of NodeInfo.
type NodeInfo_List = capnp.StructList[NodeInfo]

// NewNodeInfo creates a new list of NodeInfo.
func NewNodeInfo_List(s *capnp.Segment, sz int32) (NodeInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 2}, sz)
	return capnp.StructList[NodeInfo](l), err
}

// NodeInfo_Future is a wrapper for a NodeInfo promised by a client call.
type NodeInfo_Future struct{ *capnp.Future }

func (f NodeInfo_Future) Struct() (NodeInfo, error) {
	p, err := f.Future.Ptr()
	return NodeInfo(p.Struct()), err
}
func (p NodeInfo_Future) NodeType() NodeInfo_nodeType_Future {
	return NodeInfo_nodeType_Future{p.Future}
}

// NodeInfo_nodeType_Future is a wrapper for a NodeInfo_nodeType promised by a client call.
type NodeInfo_nodeType_Future struct{ *capnp.Future }

func (f NodeInfo_nodeType_Future) Struct() (NodeInfo_nodeType, error) {
	p, err := f.Future.Ptr()
	return NodeInfo_nodeType(p.Struct()), err
}
func (p NodeInfo_nodeType_Future) File() FileInfo_Future {
	return FileInfo_Future{Future: p.Future.Field(1, nil)}
}
func (p NodeInfo_nodeType_Future) Directory() DirectoryInfo_Future {
	return DirectoryInfo_Future{Future: p.Future.Field(1, nil)}
}
func (p NodeInfo_nodeType_Future) Symlink() SymlinkInfo_Future {
	return SymlinkInfo_Future{Future: p.Future.Field(1, nil)}
}

type FileInfo capnp.Struct

// FileInfo_TypeID is the unique identifier for the type FileInfo.
const FileInfo_TypeID = 0xbdb40fba20088e0b

func NewFileInfo(s *capnp.Segment) (FileInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return FileInfo(st), err
}

func NewRootFileInfo(s *capnp.Segment) (FileInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return FileInfo(st), err
}

func ReadRootFileInfo(msg *capnp.Message) (FileInfo, error) {
	root, err := msg.Root()
	return FileInfo(root.Struct()), err
}

func (s FileInfo) String() string {
	str, _ := text.Marshal(0xbdb40fba20088e0b, capnp.Struct(s))
	return str
}

func (s FileInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (FileInfo) DecodeFromPtr(p capnp.Ptr) FileInfo {
	return FileInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s FileInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s FileInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s FileInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s FileInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// FileInfo_List is a list of FileInfo.
type FileInfo_List = capnp.StructList[FileInfo]

// NewFileInfo creates a new list of FileInfo.
func NewFileInfo_List(s *capnp.Segment, sz int32) (FileInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[FileInfo](l), err
}

// FileInfo_Future is a wrapper for a FileInfo promised by a client call.
type FileInfo_Future struct{ *capnp.Future }

func (f FileInfo_Future) Struct() (FileInfo, error) {
	p, err := f.Future.Ptr()
	return FileInfo(p.Struct()), err
}

type DirectoryInfo capnp.Struct

// DirectoryInfo_TypeID is the unique identifier for the type DirectoryInfo.
const DirectoryInfo_TypeID = 0xf5b75bdef3ecb023

func NewDirectoryInfo(s *capnp.Segment) (DirectoryInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return DirectoryInfo(st), err
}

func NewRootDirectoryInfo(s *capnp.Segment) (DirectoryInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return DirectoryInfo(st), err
}

func ReadRootDirectoryInfo(msg *capnp.Message) (DirectoryInfo, error) {
	root, err := msg.Root()
	return DirectoryInfo(root.Struct()), err
}

func (s DirectoryInfo) String() string {
	str, _ := text.Marshal(0xf5b75bdef3ecb023, capnp.Struct(s))
	return str
}

func (s DirectoryInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (DirectoryInfo) DecodeFromPtr(p capnp.Ptr) DirectoryInfo {
	return DirectoryInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s DirectoryInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s DirectoryInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s DirectoryInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s DirectoryInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s DirectoryInfo) Links() (Link_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Link_List(p.List()), err
}

func (s DirectoryInfo) HasLinks() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s DirectoryInfo) SetLinks(v Link_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewLinks sets the links field to a newly
// allocated Link_List, preferring placement in s's segment.
func (s DirectoryInfo) NewLinks(n int32) (Link_List, error) {
	l, err := NewLink_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Link_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// DirectoryInfo_List is a list of DirectoryInfo.
type DirectoryInfo_List = capnp.StructList[DirectoryInfo]

// NewDirectoryInfo creates a new list of DirectoryInfo.
func NewDirectoryInfo_List(s *capnp.Segment, sz int32) (DirectoryInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[DirectoryInfo](l), err
}

// DirectoryInfo_Future is a wrapper for a DirectoryInfo promised by a client call.
type DirectoryInfo_Future struct{ *capnp.Future }

func (f DirectoryInfo_Future) Struct() (DirectoryInfo, error) {
	p, err := f.Future.Ptr()
	return DirectoryInfo(p.Struct()), err
}

type SymlinkInfo capnp.Struct

// SymlinkInfo_TypeID is the unique identifier for the type SymlinkInfo.
const SymlinkInfo_TypeID = 0x81890149690e6995

func NewSymlinkInfo(s *capnp.Segment) (SymlinkInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SymlinkInfo(st), err
}

func NewRootSymlinkInfo(s *capnp.Segment) (SymlinkInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return SymlinkInfo(st), err
}

func ReadRootSymlinkInfo(msg *capnp.Message) (SymlinkInfo, error) {
	root, err := msg.Root()
	return SymlinkInfo(root.Struct()), err
}

func (s SymlinkInfo) String() string {
	str, _ := text.Marshal(0x81890149690e6995, capnp.Struct(s))
	return str
}

func (s SymlinkInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (SymlinkInfo) DecodeFromPtr(p capnp.Ptr) SymlinkInfo {
	return SymlinkInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s SymlinkInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s SymlinkInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s SymlinkInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s SymlinkInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s SymlinkInfo) Target() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s SymlinkInfo) HasTarget() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s SymlinkInfo) TargetBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s SymlinkInfo) SetTarget(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// SymlinkInfo_List is a list of SymlinkInfo.
type SymlinkInfo_List = capnp.StructList[SymlinkInfo]

// NewSymlinkInfo creates a new list of SymlinkInfo.
func NewSymlinkInfo_List(s *capnp.Segment, sz int32) (SymlinkInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[SymlinkInfo](l), err
}

// SymlinkInfo_Future is a wrapper for a SymlinkInfo promised by a client call.
type SymlinkInfo_Future struct{ *capnp.Future }

func (f SymlinkInfo_Future) Struct() (SymlinkInfo, error) {
	p, err := f.Future.Ptr()
	return SymlinkInfo(p.Struct()), err
}

type Link capnp.Struct

// Link_TypeID is the unique identifier for the type Link.
const Link_TypeID = 0xe6d3c322caf5dd4b

func NewLink(s *capnp.Segment) (Link, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Link(st), err
}

func NewRootLink(s *capnp.Segment) (Link, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Link(st), err
}

func ReadRootLink(msg *capnp.Message) (Link, error) {
	root, err := msg.Root()
	return Link(root.Struct()), err
}

func (s Link) String() string {
	str, _ := text.Marshal(0xe6d3c322caf5dd4b, capnp.Struct(s))
	return str
}

func (s Link) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Link) DecodeFromPtr(p capnp.Ptr) Link {
	return Link(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Link) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Link) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Link) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Link) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Link) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Link) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Link) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Link) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Link) Size() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Link) SetSize(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Link) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Link) HasCid() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Link) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Link) SetCid(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Link_List is a list of Link.
type Link_List = capnp.StructList[Link]

// NewLink creates a new list of Link.
func NewLink_List(s *capnp.Segment, sz int32) (Link_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Link](l), err
}

// Link_Future is a wrapper for a Link promised by a client call.
type Link_Future struct{ *capnp.Future }

func (f Link_Future) Struct() (Link, error) {
	p, err := f.Future.Ptr()
	return Link(p.Struct()), err
}

type PeerInfo capnp.Struct

// PeerInfo_TypeID is the unique identifier for the type PeerInfo.
const PeerInfo_TypeID = 0xa06f294430ac72ff

func NewPeerInfo(s *capnp.Segment) (PeerInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return PeerInfo(st), err
}

func NewRootPeerInfo(s *capnp.Segment) (PeerInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return PeerInfo(st), err
}

func ReadRootPeerInfo(msg *capnp.Message) (PeerInfo, error) {
	root, err := msg.Root()
	return PeerInfo(root.Struct()), err
}

func (s PeerInfo) String() string {
	str, _ := text.Marshal(0xa06f294430ac72ff, capnp.Struct(s))
	return str
}

func (s PeerInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (PeerInfo) DecodeFromPtr(p capnp.Ptr) PeerInfo {
	return PeerInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s PeerInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s PeerInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s PeerInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s PeerInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s PeerInfo) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s PeerInfo) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s PeerInfo) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s PeerInfo) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s PeerInfo) Addresses() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s PeerInfo) HasAddresses() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s PeerInfo) SetAddresses(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewAddresses sets the addresses field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s PeerInfo) NewAddresses(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s PeerInfo) Protocols() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.TextList(p.List()), err
}

func (s PeerInfo) HasProtocols() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s PeerInfo) SetProtocols(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewProtocols sets the protocols field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s PeerInfo) NewProtocols(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// PeerInfo_List is a list of PeerInfo.
type PeerInfo_List = capnp.StructList[PeerInfo]

// NewPeerInfo creates a new list of PeerInfo.
func NewPeerInfo_List(s *capnp.Segment, sz int32) (PeerInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[PeerInfo](l), err
}

// PeerInfo_Future is a wrapper for a PeerInfo promised by a client call.
type PeerInfo_Future struct{ *capnp.Future }

func (f PeerInfo_Future) Struct() (PeerInfo, error) {
	p, err := f.Future.Ptr()
	return PeerInfo(p.Struct()), err
}

const schema_da965b22da734daf = "x\xda\xb4X{\x90\x14\xe5\xb5?\xa7{\xc6^tg" +
	"gzz\x97u\x10\xdc\xcb\xb2\x96\xb2\x05[^VE" +
	"\xf6\x965sY\x16\xee*\xe06\x0b\xbe\xf1\xda\xcc4" +
	"\xd82\xdb=t\xf7 c\xa1\xf8@SXJ\x14\xa3" +
	"%F*R\xf1\xad(\xc1\x10\"\x09\x11\x93\xe03\x96" +
	"\x9a \x96\x1a5*h\xc4`\x94\xb8*\xc6\xb5S\xa7" +
	"g\xba\xfb\xdb\xde\xd9ER\x95\xff\xa6\xfa\x9c9\xef\xc7" +
	"\xef;'_]\x93\x89\xfcw\xec\xe5\x14p\xbd\x930" +
	"z\x94s\xbbV\xa7u\xe3\x9ak@\x8c\xa1\xf3\xf8\x1c" +
	"\xeb\xcd\xe6\x0b\xefx\x13\xa2(\x00H/\xd5\xbe \xbd" +
	"QK\xbf^\xabM\x03:\xab\xc7D\x1ao:e\xf5" +
	"\xb5 &\x11*<\xfd\xb5\x07\x01\xa5C.\xfd\x93g" +
	"\x9f\xe9\xddm\x8f\xbd\x0e\xe4$\xa2s\xce\xbaO\xa5G" +
	"\x1e\xfc\xe4:\xe8B\x81\x03\x90R\xb1\xfd\xd2\x091\xfa" +
	"\xcf\xf8\xd8\xe5\xc0\xd0\xc5\x18\x1fh\x06\x94\x94\xd8:I" +
	"\x8b5\x02H\xc5\xd8,i\x03\xfd\xc5\xb9q\xce\xb9\xab" +
	"\x9f<\xe3\xb3\xd5 \xc6\xb8A\xcc\xd7\xc7\xb6K7\xbb" +
	"R\xd7\xc4\xce\x06t^O\xee\xdf\x1e\xdf\xb4\xfc&\xd6" +
	"\xc6\x8d\xb1o\x00\xa5\xfbbd\xe3\x89\x13f5\xec|" +
	"\xf5\x86\xb5\x0c\xbd}W\x8cC@\xe9y\x97\xe1\x95\xcf" +
	"\xe6o+\xdc\xd0~\x0b+`\xc0\x15\x80uD\xcf\xbc" +
	"8\xed\x81ik\xd3\xebAn@\x04\x88\x90\x80\xf1u" +
	"\xad$`\xa2\xcb\xb0y\xef\x0fO\x9d\xd1\xf6\xd5\xdd\xac" +
	"\x86\xee2\x83\xec2\x8c\xdd\xba\xf8\xc0\x1f'\xcd\xbe\x07" +
	"\xc4\xd1>\xc3\xb2\xbafb(\xb9\x0c\x8e\xf9\xe8\xc93" +
	"&\x1a\xf7\x84r\xc2\x93)\xeb\xeb\xb6H\x1b\xeb\xe8\xd7" +
	"\x86\xba\xc7\x01\x9d\x17w\xce\xdb\xf3\xfa\x92\xc6\x9f\x920" +
	"\xa7\xb3\xeb\xba\x99\xfa\xc5\x7f\xff\x03D\xa3\xc4\xb10~" +
	"P\xd2\xe2\x8d\x00\xed\xc5x\x13\x02:?\xf8\xd5\x85\x0b" +
	"\x95O'?\xe0&\xa8b\xfb\x93\x09\xd7\xf9\x1d\x09\xd2" +
	"\x1c\x9d\xba\xe0\xc3Gv\xa7\x1f\x049\x86LR\xa2\x1c" +
	"\x89{;\xb1E\xda\x97\xa0_\xef%>\x02t&8" +
	"_r\xe9\xe3\xde}xP\xa8\xc5\xf7)\xd4\"\x09\xdb" +
	"\xfb\xec\x8e\x09\xc5\xc7\x1e\xde\xc4\xd2w\x89\xfb)\xd2." +
	"\xddXz\x8cvJ\xf61\x96\xde\xfe\xb1x4Y\xf3" +
	"\xb9\xcb\xb0\xe4\x9e\xce\xb1]\xeb?\xdcVf k%" +
	"1\xf9>D\x9c\xcb~?\xfd\xaf\xef\xbcu`\x1b\xc8" +
	"\xa3\x91\xf1\xba\\h\xed\xfd\xe2\x18\x94\xa2Ib\xc7$" +
	"U\xda1O\xd4M<\xfdj\xe1\x97\x95\x80\x933\xed" +
	"\xff\x9b\x1cC\x8a\xba]\x86\xec\xdc{\x1f\xdb\xfb\xdam" +
	"\xdbYK\xefK\x92\xa5\x0f%\xc9\x90c\xd6\xd6\xfc\xd7" +
	"\xf6\xf8\xcfw\x0cN\x88k\xd0\xf3\xc9-\xd2\xabI\x01" +
	"xg\xca\xfd\x9b\xf0\xa9\xa5\x1b\x7f[\x11\xe2j\xd9\x94" +
	"\x9cBZ\xb6\xbaZR\x07zn\x98\xd4\xf1\xdd.6" +
	"\xfa\xa2\x94$\x86\x94Dj\xee\xfe\xf1\x8f\xe6\xce<\xad" +
	"\xf7\x19\xd6\x8ci\x12\x99q\x86K\xbfm\x97~\xf1\x9c" +
	"\xf3\xc6\xbe\xc8\xd2\xfb$*\xcde.\xfd4\xfb\xfe\x95" +
	"\xd1;:\x06\xd1o\x95\xa8?ow\xe9~\xa0\xc2\x1d" +
	"\xb7U\xda\"\xed\x90N\xa4F\x97fI\x03\x12u\xdc" +
	"\x97m\x17\xddu\x89\xb4\xfe%\x10\x8fg\xaa\xac\xec\xd6" +
	">i\x11J\x87$\xb7\xff%r\xed\xe2\xd3w\xfe\xb3" +
	"\xb0\xfa\xcc\xdd\xacf\xb9\x9e,_P\x9f\x06\x1cx\xe2" +
	"\xd4\x0b6L\xda\xb9\x87\xa1\x16\xeb\xc9\xae\x12Q\x9d\xe3" +
	"\xf7\xec\xfd\xc9\xcb\xdf~\xf0\x06\xc8\x13\x10\x83\xe46\xa0" +
	"\x80\x00\xed\xeb\xeb;(D\x1b\xebI\xd1\xdd\xdf\x0aS" +
	"\x8e}\xee\xb9\xb7\x98\x92\x18\xa8\xff\x06\"\xce\xdb\xe6\xbb" +
	"\xed\xb6\xf1\xc2\x9fA\x1e\x87\xcc$\xaa\xc8x\xaf\xde-" +
	"\xab\x8f]\x19\xcd\xfa\xca\x1b/i=\xf8\x17\xd6\xd8\xae" +
	"\x06\x0acw\x03\x99\xf3\x8b\x0f\x9e<0g\xc9\xee\xf7" +
	"\xa8\xba\xf8\xa0%\x16p\x02\xf2X#\x95\\\xd6+\x1b" +
	"\xa8\xfb^\xbej\xcf\xda\xd3\xce\x19\xb5\x8f\xfa\x85\x0b\xf7" +
	"Kj\xf4]\xd2\xf8\xd1\xf4k\xdch\xea\x97\xb3\xde\xee" +
	"\x7f\xa1\xf9w\x7f\xfa\x90\x981\xcc\xfc\xf9\xe8u\xd2!" +
	"\x97\xb9\x7f4I\xde\xbf\xb3\xf6\xd7\x0f\xfc\xe6\xce\x8f\x18" +
	"Gon<\x08\x11\xa7\x7fB\xc3Y\x07\xb7nc\x09" +
	"\xcb\\\xc2Y\xe3\xfe\xe7D\xee\xff\xaf\xfalHv\x17" +
	"4\xae\x93\x166R\xde\xceo|\x96\x93\x1aR\x94\xde" +
	"kk7_\xb4w\xfe\xd4/@l\xf0\x9bo\xe0X" +
	"w\x08ES\x14\x85\xc8\xd3O\xed\x9c\xfa\x85\xf6\x05\x1b" +
	"\xa5\x13R\x94\xd2\x89.}\xc2\xe6\xbf\xfd\xe3\x9d\x0b\xb7" +
	"\xf5W[\x1csRoJ\xe7\x93\x1ai\x81\xcb\xdb\xdf" +
	"?M\xe8\xe8O}=\xc4\xb4\xebS\x0fK7\xbb\x8c" +
	"kR\xb3\xa4\x9f\xb9\x96-<\xf7\x95{\xd7L=\xee" +
	"k\xa6M\xa4\xf5)\xaa\x96\x0d\xa948p\xaac\x95" +
	",[\xedk\xcbrJA/t\xf4\x96\xfa\xf2\x9a\xbe" +
	"\xb4[_l\x00\xf4 \xca\x11>\x02\x10A\x001\xd6" +
	"\x01 \xd7\xf0(\xd7s\x98\xb6\x15s\x89jc-p" +
	"X\x0b\x18\x12\xd2\xdd3\xb3\xb7\xcd\xb2\x15\xbb\xa5\xa7I" +
	"1\x95>\x8b\x95\xd2\x1cH\x11\xb2Zn\x18\x11\x9dj" +
	">\xdf6G)-R\xbb\xe2\xa6i\x98dJ\x0d\x1f" +
	"\xa9u\x1cW\xca\xc41\x00r\x0b\x8f\xf2\xc9\x1c\xc6\xf0" +
	";\x071\xa8Yqr3p\xbc\xb1\x14\x8e\x12T\xd3" +
	"\xf4\xe5\xa2'\x17\xf3r\x84\xadj\x11/p\xca\x9aL" +
	"\x13x\xc3\x94#|\x14\xc0/\x0d\xf4\x06\x85(\xb6\x02" +
	"'F\x85\xf8\xe5\x8afg\xb0\x071$\xbbK\xb7\xd3" +
	"fi~\xa9\xa0\x92\xb5\xb5\xc8\x01\x88\xe3Z\x01\x10\xc5" +
	"\x86y\x00\xc8\x89\xe2t\x80\xf8b-\xaf:9\xcdT" +
	"\xb3\xb6a\x02\x96VY\xe5\x98W\x0bbQ/hz" +
	"K\xba\xe7\x88\xa3\xc8\x072\x0a\xaajZ-\xf3T\xab" +
	"\x98\xb7-`\x85\x9c\x09 \xd7\xf2(\x9f\xc4\xa1C\\" +
	"\xb35\xcb\x06\x00\xac\x03\xec\xe1\x11\x13\xc1\xee\x04\xa4\x8f" +
	"\xc3\xa6y^\xba,\x9d\x15\xde\x1aX\x18\xd7\xf4\xc5\x06" +
	"&\x82\xee\x07\xc4\xc4\x10c;\x0d\xdd2\xf2j[\xc1" +
	"\xd4t;\xaf\x93\xc5\xf1\xb0\xd0d \x14u\xac\x01\x0e" +
	"k\xaa;m\xaa\x96\x91_\xae\xce5rjK\x8f\x12" +
	"\x0f\x87\x8f5\xae\xa0\xd8\x97\x0e\x13\xbf\xae\x15j\xb6h" +
	"\x1bf\x9bUP.w-*\x0a#\xb8\x99U\xf3y" +
	"L\x0437\xe4f\xb9JzT\xb5\xc9\xa4\xfer\x8b" +
	"\xc4\x17\xd4E\x15\x9d\xe1Q\x9e\xcd\xa1\x88XO\xdd*" +
	"v\xcf\x03\x90\xff\x8fG9\xc7\xa1\xc8q\xf5nI)" +
	"\xf4\xf1\x12\x1e\xe5\x95\x1c\xf2L\xea\x95\\\xceT-K" +
	"\x05\xb4\xbc\x0c\x12\x89\xf2V0\x0d\xdb\xc8\x1a\xf9*\xa4" +
	"\xc1)\xf5\x1d\xee4\x9a\xfa\xfa\x14=\xe7\xb6J\xb0\xbd" +
	"\xd0t:\x95\xc2\x0c\xd5\xca\x9a\xd0\xa4\x15l\xc3\x94\xeb" +
	"}\x17\xae\xa4X\xac\xe0Q^\xcd\xb8p\x0d}\\\xc9" +
	"\xa3|'\xe3\xc2\xedT\xbe\xb7\xf0(?\xca\xa1\xc8\xf3" +
	"\xf5\xc8\x03\x88\x0f\xd1\xc7{y\x947s(F\"\xf5" +
	"\x18\x01\x107\x91\xb3\x8f\xf2(?\x17\xcaT\\1\x97" +
	"\x84\x9d\x11T}y\xf8SN3\xfd\x08\xa9+lS" +
	"\xe9T\x0aL\x18\x12\x81s\xa1\x1a\xe7\xc3]X\xad\x83" +
	"\xa6\x07\xd9_e\x15\xb3Y\xd5\xb2\x10\x81C\x1c\x92\xf6" +
	"\xb9F\xaeI\xf5\xd2\x9e\xf0%(\xe4\xf4E<\xca\x97" +
	"r\xe8\x85Lm\xad$8O!\xc3r\xc8\xb4+\x00" +
	"\xe4Ky\x94m\x0e\x91Gf\xb1\x8a\xcb\xce\x04\x8e\x1d" +
	"\x02qK\xbbB\xc5Q\xc0\xe1(\x82c\xc5\xbeb^" +
	"\xb15H/W{Y\x82n\xe4T\x1aV\x00P\xad" +
	"\xb1\xf3VK\x8fb\x0aG\xda8\x8c\x84,-\x80\xa1" +
	"\xbdw\x04\xa3+k\xe8\xba\x9a%)$\x04`8K" +
	"\xa8\xf4G\xb2D\xcby\xbe\x0c\xd7\xe0g\x17l\xcd\xd0" +
	"\x95|\xa7\xca\xe7\xf3\xe1e\xd3:d\xd9\xf8 \xcb]" +
	"6\xe5\xc6\x17\x83G\x18\x8d|*Gf\xfdT\x1d(" +
	"\xe4\x17\xdfg\x91\xb2\x8a[\xac.\xbf\x87&S\x99\x9d" +
	"\xc4\xa3|\x0a\x87qr\x08\xc5\x00\xa0\x94u\xad\xca\x1a" +
	"n\xbfb\"\x80\x97\xa1\xf1\xc3\xc4\x83\xca\xf9\xdf\xc8L" +
	"\xb9\x92gjy\xbf\x92\x0f7z\xe7\xa9M\xe5\xc5\xc0" +
	"x\xd8\\\xcd\xc3\xd6\xc0\xc3A\xa5LE\x8a\xa2\xe3t" +
	">s\xe8\xaa\xaf^\xdf[\xf1v\xa4Z)\xb7)Z" +
	"G\xda\xa6\x83K\xbf\xda\xf2\xf1\xa4\xb4p\xb8J\xd5m" +
	"SS\x991\xe2\x83\xd7\xaa\xab\xd2\x853\x84\x1b\xaa\xae" +
	"J\x16X\x99e\xf3\x13\x01>\x19>\x8d\xd4`~\x84" +
	"\x87i\x8dEF\xae\x841\xe006$\x91]+\xd4" +
	"&\xb7\x1a\xe5\x1ad\xdf\xbe\xa3\xa6\x07+L\x8c^\xb6" +
	"\xaa\xb3\\Z\x8e\xd7#\x10'w*0\xc9{\x0e\xa2" +
	"\xf7\x10\x17\xc5).LjrK|0N\x8a\x84\x97" +
	"\x8c+\xb8\xcd[)ZA\xb0}\xa87bCt0" +
	"\x0d\xa1+}\xaaW/\xe9l^Su\x1b\x93\x11\x1e" +
	"\x10\x93\xd5\xc3\xa6\xe4r\x87\xc3\x049\xc5V\x86D-" +
	"$\xa2Z\xe4\xbf\xdfl\xab2u\xd2\xf9|\x9bj\x9a" +
	"\xe4x\xa2\xe2\xe4\xc4\x8e\xc0s\xacl\x01\xb6O\xd2\x04" +
	"\xbd\x8a\x96\x87\x82\xaag\x9a\x0b\xe3\xc0\x0a\x96\x0cc\xaf" +
	"\x00n\x13\xda&S\\O\xfes\xc6h\xba5\"l" +
	"l!<\xa5\xe5\x0e\x83Wh\xc8\xd0(j\xd3\x8dt" +
	"y\x9b\x11\xa4\x1a\xeb8X\xc6\x14]\xad\x01\xaa\x1aG" +
	"\xa3\xbb\x8c*|\\5\x9f\xc3q\xdc\x00}\x8e\x02\x88" +
	"2u\xf8l\x1e\xe5\xf38ta:&\x82kE\xa5" +
	"\x0d\x19\xe0\x8e\x89\xe0\xddV\xa6zP\x1e\x13\xc1)\xb0" +
	"*\x08\xec\xd2m\xde,\x85\xa0@\xeb\xf7\x85\x02\xf41" +
	"\xc7\xa3\\ \xf4T\xf1\xb4\xaf9\xc0\x07\x83Z\"n" +
	"\x97\x0a*\xc6\x83\xa3\x1f \xc6C a\x84i?[" +
	"\xd3qi\x08\xaa2A\xf5\x91*}\x9b\xc1\xa3\xdc\xc3" +
	"\x18:\xa79\x08\xf3`\x9b\x0e\xab<\\*\x95\x87\xe4" +
	"\xb0c5LG\xef\xff\xd8K\xc6Org\x95wX" +
	"\xc1'\xa0|B\x91dl\x06N\xeaB\x01\x83\x0b\x1b" +
	"z\x97\x1fi\x9aK\x9d\x8c\x02r\xfe}\x0e\xbd\xbb\x92" +
	"4\x1e\xc7\x00'5\xa0\x80\xbc\x7f\xccE\xef\xe0)\x8d" +
	"Bz-\x0e\x08\x18\xf1\x0fb\xe8=\xc6\xc5\xcf\x9b\x81" +
	"\x13\xf7\x09\x18\xf5/\xac\xe8]\x13\xc57h|\xbe$" +
	"\xe0Q\xfe\xd5\x02\xbd\x1b\x8b\xf84\xc9\xdc*\xa0\xe0_" +
	"\xf3\xd0\xbb,\x88\x0f\x8d\x01N\xdc `\x8d\x7f\x0aD" +
	"\xefF&\xde:\x1d8\xf1z\x01G\xf9'\x1f\xf4N" +
	"\xb7b\x89\xf4\xf5\x09x\xb4\x7fkE\xef\xf8&*\x8b" +
	"\x80\x13\xcf\x17\x04%\x97\xcb\xa0\x90U\xec\x0c\xf2y+" +
	"\x83q\xea\xf6\x0c\x0a\x05M\xcf`\x93\x0b\x8f3\x18\xa7" +
	"De\xe8I\x92!8\xe2n\xe3\x0c6\xb9c'\x83" +
	"\x8e\x07\x0b@0r\xea\xe0\xb5P\xfd\xfdW\x05}\xb2" +
	"\x8b\xd2(\xda\x85\xa2}\x18\xd4Wm\x8d{\xaf\xdec" +
	"+\xaf\xde\xf2\xad\x03B\xcf\xdd\xa1+wF\xa5\xf3K" +
	"\xdd:_\x86\xf1\x8c\xd0)\xc1\xd8j\xa2\x09\xc0 \x03" +
	"\xffR\x15B\x06\xe8y\x1d'\xb7\xcb\xf2\xa2\xcc1\x09" +
	"\xbd\xe3\xb8(Nw7\xea\xaaJd\x06\x07/\x04\xeb" +
	"\xaam\xa5\x11\xe0\xcf\xbf\x02\x00\x00\xff\xff\x99\x7f{\xf0"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_da965b22da734daf,
		Nodes: []uint64{
			0x81890149690e6995,
			0x8284348c17041a84,
			0x831c74d453c6c7eb,
			0x83eba8ab13ee9256,
			0x84f03db984574d8a,
			0x8c76ad0fbaea12d7,
			0x8e86d1c015472327,
			0x90338670b754f0d0,
			0x993f8e39a739cb40,
			0x9cf72e44358fe4b0,
			0xa04c2cd2ed66b51c,
			0xa06f294430ac72ff,
			0xa31767d7d652c0cb,
			0xa72dee615d5bbb87,
			0xa83fd4abe6553705,
			0xaadf1b3f02f6ff23,
			0xadaaae7523bdc7e4,
			0xadae6334690b6b6f,
			0xb7e699451c43a067,
			0xb7eddbdee842c46a,
			0xb8078038290eb30b,
			0xba93d5e4aea44e63,
			0xbdb40fba20088e0b,
			0xc2a16bbf01ada632,
			0xc5fe3a2c8650ed19,
			0xc65336464e949b9c,
			0xcb1c584d5e6ec593,
			0xcb3a96057ca67436,
			0xccef5e6e46834543,
			0xcd9913609a5c2ef6,
			0xd44a8470fbc0385e,
			0xd6c02c9d5a3500b3,
			0xd9e3fccf9fe4d61e,
			0xdbc8c8183207fc9c,
			0xdcca6f7433df72dd,
			0xe0f22a608a7c6e22,
			0xe1d4674dedb9e3b6,
			0xe50956368ed67ecf,
			0xe6d3c322caf5dd4b,
			0xe798bea7bc0cc0ea,
			0xe7b7b5f24b1523f5,
			0xf07e5f02273b1d4b,
			0xf43754e45cb00c82,
			0xf469f437c0bfc104,
			0xf5b75bdef3ecb023,
			0xf819f53a0739f5f5,
			0xf81b3789a4d0575d,
		},
		Compressed: true,
	})
}
