// Code generated by capnpc-go. DO NOT EDIT.

package system

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
)

type IPFS capnp.Client

// IPFS_TypeID is the unique identifier for the type IPFS.
const IPFS_TypeID = 0xf07e5f02273b1d4b

func (c IPFS) Add(ctx context.Context, params func(IPFS_add_Params) error) (IPFS_add_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      0,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "add",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_add_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_add_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Cat(ctx context.Context, params func(IPFS_cat_Params) error) (IPFS_cat_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      1,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "cat",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_cat_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_cat_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Ls(ctx context.Context, params func(IPFS_ls_Params) error) (IPFS_ls_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      2,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "ls",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_ls_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_ls_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Stat(ctx context.Context, params func(IPFS_stat_Params) error) (IPFS_stat_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      3,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "stat",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_stat_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_stat_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Pin(ctx context.Context, params func(IPFS_pin_Params) error) (IPFS_pin_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      4,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "pin",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_pin_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_pin_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Unpin(ctx context.Context, params func(IPFS_unpin_Params) error) (IPFS_unpin_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      5,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "unpin",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_unpin_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_unpin_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Pins(ctx context.Context, params func(IPFS_pins_Params) error) (IPFS_pins_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      6,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "pins",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_pins_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_pins_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Id(ctx context.Context, params func(IPFS_id_Params) error) (IPFS_id_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      7,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "id",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_id_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_id_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Connect(ctx context.Context, params func(IPFS_connect_Params) error) (IPFS_connect_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      8,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "connect",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_connect_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_connect_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) Peers(ctx context.Context, params func(IPFS_peers_Params) error) (IPFS_peers_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      9,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "peers",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(IPFS_peers_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return IPFS_peers_Results_Future{Future: ans.Future()}, release

}

func (c IPFS) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c IPFS) String() string {
	return "IPFS(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c IPFS) AddRef() IPFS {
	return IPFS(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c IPFS) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c IPFS) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c IPFS) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (IPFS) DecodeFromPtr(p capnp.Ptr) IPFS {
	return IPFS(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c IPFS) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c IPFS) IsSame(other IPFS) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c IPFS) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c IPFS) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A IPFS_Server is a IPFS with a local implementation.
type IPFS_Server interface {
	Add(context.Context, IPFS_add) error

	Cat(context.Context, IPFS_cat) error

	Ls(context.Context, IPFS_ls) error

	Stat(context.Context, IPFS_stat) error

	Pin(context.Context, IPFS_pin) error

	Unpin(context.Context, IPFS_unpin) error

	Pins(context.Context, IPFS_pins) error

	Id(context.Context, IPFS_id) error

	Connect(context.Context, IPFS_connect) error

	Peers(context.Context, IPFS_peers) error
}

// IPFS_NewServer creates a new Server from an implementation of IPFS_Server.
func IPFS_NewServer(s IPFS_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(IPFS_Methods(nil, s), s, c)
}

// IPFS_ServerToClient creates a new Client from an implementation of IPFS_Server.
// The caller is responsible for calling Release on the returned Client.
func IPFS_ServerToClient(s IPFS_Server) IPFS {
	return IPFS(capnp.NewClient(IPFS_NewServer(s)))
}

// IPFS_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func IPFS_Methods(methods []server.Method, s IPFS_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 10)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      0,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "add",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Add(ctx, IPFS_add{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      1,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "cat",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Cat(ctx, IPFS_cat{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      2,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "ls",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Ls(ctx, IPFS_ls{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      3,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "stat",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Stat(ctx, IPFS_stat{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      4,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "pin",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Pin(ctx, IPFS_pin{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      5,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "unpin",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Unpin(ctx, IPFS_unpin{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      6,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "pins",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Pins(ctx, IPFS_pins{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      7,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "id",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Id(ctx, IPFS_id{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      8,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "connect",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Connect(ctx, IPFS_connect{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf07e5f02273b1d4b,
			MethodID:      9,
			InterfaceName: "system.capnp:IPFS",
			MethodName:    "peers",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Peers(ctx, IPFS_peers{call})
		},
	})

	return methods
}

// IPFS_add holds the state for a server call to IPFS.add.
// See server.Call for documentation.
type IPFS_add struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_add) Args() IPFS_add_Params {
	return IPFS_add_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_add) AllocResults() (IPFS_add_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_add_Results(r), err
}

// IPFS_cat holds the state for a server call to IPFS.cat.
// See server.Call for documentation.
type IPFS_cat struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_cat) Args() IPFS_cat_Params {
	return IPFS_cat_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_cat) AllocResults() (IPFS_cat_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_cat_Results(r), err
}

// IPFS_ls holds the state for a server call to IPFS.ls.
// See server.Call for documentation.
type IPFS_ls struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_ls) Args() IPFS_ls_Params {
	return IPFS_ls_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_ls) AllocResults() (IPFS_ls_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_ls_Results(r), err
}

// IPFS_stat holds the state for a server call to IPFS.stat.
// See server.Call for documentation.
type IPFS_stat struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_stat) Args() IPFS_stat_Params {
	return IPFS_stat_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_stat) AllocResults() (IPFS_stat_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_stat_Results(r), err
}

// IPFS_pin holds the state for a server call to IPFS.pin.
// See server.Call for documentation.
type IPFS_pin struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_pin) Args() IPFS_pin_Params {
	return IPFS_pin_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_pin) AllocResults() (IPFS_pin_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_pin_Results(r), err
}

// IPFS_unpin holds the state for a server call to IPFS.unpin.
// See server.Call for documentation.
type IPFS_unpin struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_unpin) Args() IPFS_unpin_Params {
	return IPFS_unpin_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_unpin) AllocResults() (IPFS_unpin_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_unpin_Results(r), err
}

// IPFS_pins holds the state for a server call to IPFS.pins.
// See server.Call for documentation.
type IPFS_pins struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_pins) Args() IPFS_pins_Params {
	return IPFS_pins_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_pins) AllocResults() (IPFS_pins_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_pins_Results(r), err
}

// IPFS_id holds the state for a server call to IPFS.id.
// See server.Call for documentation.
type IPFS_id struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_id) Args() IPFS_id_Params {
	return IPFS_id_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_id) AllocResults() (IPFS_id_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_id_Results(r), err
}

// IPFS_connect holds the state for a server call to IPFS.connect.
// See server.Call for documentation.
type IPFS_connect struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_connect) Args() IPFS_connect_Params {
	return IPFS_connect_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_connect) AllocResults() (IPFS_connect_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_connect_Results(r), err
}

// IPFS_peers holds the state for a server call to IPFS.peers.
// See server.Call for documentation.
type IPFS_peers struct {
	*server.Call
}

// Args returns the call's arguments.
func (c IPFS_peers) Args() IPFS_peers_Params {
	return IPFS_peers_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c IPFS_peers) AllocResults() (IPFS_peers_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_peers_Results(r), err
}

// IPFS_List is a list of IPFS.
type IPFS_List = capnp.CapList[IPFS]

// NewIPFS creates a new list of IPFS.
func NewIPFS_List(s *capnp.Segment, sz int32) (IPFS_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[IPFS](l), err
}

type IPFS_add_Params capnp.Struct

// IPFS_add_Params_TypeID is the unique identifier for the type IPFS_add_Params.
const IPFS_add_Params_TypeID = 0xd44a8470fbc0385e

func NewIPFS_add_Params(s *capnp.Segment) (IPFS_add_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_add_Params(st), err
}

func NewRootIPFS_add_Params(s *capnp.Segment) (IPFS_add_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_add_Params(st), err
}

func ReadRootIPFS_add_Params(msg *capnp.Message) (IPFS_add_Params, error) {
	root, err := msg.Root()
	return IPFS_add_Params(root.Struct()), err
}

func (s IPFS_add_Params) String() string {
	str, _ := text.Marshal(0xd44a8470fbc0385e, capnp.Struct(s))
	return str
}

func (s IPFS_add_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_add_Params) DecodeFromPtr(p capnp.Ptr) IPFS_add_Params {
	return IPFS_add_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_add_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_add_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_add_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_add_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_add_Params) Data() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s IPFS_add_Params) HasData() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_add_Params) SetData(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// IPFS_add_Params_List is a list of IPFS_add_Params.
type IPFS_add_Params_List = capnp.StructList[IPFS_add_Params]

// NewIPFS_add_Params creates a new list of IPFS_add_Params.
func NewIPFS_add_Params_List(s *capnp.Segment, sz int32) (IPFS_add_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_add_Params](l), err
}

// IPFS_add_Params_Future is a wrapper for a IPFS_add_Params promised by a client call.
type IPFS_add_Params_Future struct{ *capnp.Future }

func (f IPFS_add_Params_Future) Struct() (IPFS_add_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_add_Params(p.Struct()), err
}

type IPFS_add_Results capnp.Struct

// IPFS_add_Results_TypeID is the unique identifier for the type IPFS_add_Results.
const IPFS_add_Results_TypeID = 0xd6c02c9d5a3500b3

func NewIPFS_add_Results(s *capnp.Segment) (IPFS_add_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_add_Results(st), err
}

func NewRootIPFS_add_Results(s *capnp.Segment) (IPFS_add_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_add_Results(st), err
}

func ReadRootIPFS_add_Results(msg *capnp.Message) (IPFS_add_Results, error) {
	root, err := msg.Root()
	return IPFS_add_Results(root.Struct()), err
}

func (s IPFS_add_Results) String() string {
	str, _ := text.Marshal(0xd6c02c9d5a3500b3, capnp.Struct(s))
	return str
}

func (s IPFS_add_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_add_Results) DecodeFromPtr(p capnp.Ptr) IPFS_add_Results {
	return IPFS_add_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_add_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_add_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_add_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_add_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_add_Results) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_add_Results) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_add_Results) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_add_Results) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_add_Results_List is a list of IPFS_add_Results.
type IPFS_add_Results_List = capnp.StructList[IPFS_add_Results]

// NewIPFS_add_Results creates a new list of IPFS_add_Results.
func NewIPFS_add_Results_List(s *capnp.Segment, sz int32) (IPFS_add_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_add_Results](l), err
}

// IPFS_add_Results_Future is a wrapper for a IPFS_add_Results promised by a client call.
type IPFS_add_Results_Future struct{ *capnp.Future }

func (f IPFS_add_Results_Future) Struct() (IPFS_add_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_add_Results(p.Struct()), err
}

type IPFS_cat_Params capnp.Struct

// IPFS_cat_Params_TypeID is the unique identifier for the type IPFS_cat_Params.
const IPFS_cat_Params_TypeID = 0xadaaae7523bdc7e4

func NewIPFS_cat_Params(s *capnp.Segment) (IPFS_cat_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_cat_Params(st), err
}

func NewRootIPFS_cat_Params(s *capnp.Segment) (IPFS_cat_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_cat_Params(st), err
}

func ReadRootIPFS_cat_Params(msg *capnp.Message) (IPFS_cat_Params, error) {
	root, err := msg.Root()
	return IPFS_cat_Params(root.Struct()), err
}

func (s IPFS_cat_Params) String() string {
	str, _ := text.Marshal(0xadaaae7523bdc7e4, capnp.Struct(s))
	return str
}

func (s IPFS_cat_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_cat_Params) DecodeFromPtr(p capnp.Ptr) IPFS_cat_Params {
	return IPFS_cat_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_cat_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_cat_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_cat_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_cat_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_cat_Params) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_cat_Params) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_cat_Params) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_cat_Params) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_cat_Params_List is a list of IPFS_cat_Params.
type IPFS_cat_Params_List = capnp.StructList[IPFS_cat_Params]

// NewIPFS_cat_Params creates a new list of IPFS_cat_Params.
func NewIPFS_cat_Params_List(s *capnp.Segment, sz int32) (IPFS_cat_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_cat_Params](l), err
}

// IPFS_cat_Params_Future is a wrapper for a IPFS_cat_Params promised by a client call.
type IPFS_cat_Params_Future struct{ *capnp.Future }

func (f IPFS_cat_Params_Future) Struct() (IPFS_cat_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_cat_Params(p.Struct()), err
}

type IPFS_cat_Results capnp.Struct

// IPFS_cat_Results_TypeID is the unique identifier for the type IPFS_cat_Results.
const IPFS_cat_Results_TypeID = 0xcb3a96057ca67436

func NewIPFS_cat_Results(s *capnp.Segment) (IPFS_cat_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_cat_Results(st), err
}

func NewRootIPFS_cat_Results(s *capnp.Segment) (IPFS_cat_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_cat_Results(st), err
}

func ReadRootIPFS_cat_Results(msg *capnp.Message) (IPFS_cat_Results, error) {
	root, err := msg.Root()
	return IPFS_cat_Results(root.Struct()), err
}

func (s IPFS_cat_Results) String() string {
	str, _ := text.Marshal(0xcb3a96057ca67436, capnp.Struct(s))
	return str
}

func (s IPFS_cat_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_cat_Results) DecodeFromPtr(p capnp.Ptr) IPFS_cat_Results {
	return IPFS_cat_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_cat_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_cat_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_cat_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_cat_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_cat_Results) Body() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s IPFS_cat_Results) HasBody() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_cat_Results) SetBody(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// IPFS_cat_Results_List is a list of IPFS_cat_Results.
type IPFS_cat_Results_List = capnp.StructList[IPFS_cat_Results]

// NewIPFS_cat_Results creates a new list of IPFS_cat_Results.
func NewIPFS_cat_Results_List(s *capnp.Segment, sz int32) (IPFS_cat_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_cat_Results](l), err
}

// IPFS_cat_Results_Future is a wrapper for a IPFS_cat_Results promised by a client call.
type IPFS_cat_Results_Future struct{ *capnp.Future }

func (f IPFS_cat_Results_Future) Struct() (IPFS_cat_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_cat_Results(p.Struct()), err
}

type IPFS_ls_Params capnp.Struct

// IPFS_ls_Params_TypeID is the unique identifier for the type IPFS_ls_Params.
const IPFS_ls_Params_TypeID = 0xaadf1b3f02f6ff23

func NewIPFS_ls_Params(s *capnp.Segment) (IPFS_ls_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_ls_Params(st), err
}

func NewRootIPFS_ls_Params(s *capnp.Segment) (IPFS_ls_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_ls_Params(st), err
}

func ReadRootIPFS_ls_Params(msg *capnp.Message) (IPFS_ls_Params, error) {
	root, err := msg.Root()
	return IPFS_ls_Params(root.Struct()), err
}

func (s IPFS_ls_Params) String() string {
	str, _ := text.Marshal(0xaadf1b3f02f6ff23, capnp.Struct(s))
	return str
}

func (s IPFS_ls_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_ls_Params) DecodeFromPtr(p capnp.Ptr) IPFS_ls_Params {
	return IPFS_ls_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_ls_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_ls_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_ls_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_ls_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_ls_Params) Path() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_ls_Params) HasPath() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_ls_Params) PathBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_ls_Params) SetPath(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_ls_Params_List is a list of IPFS_ls_Params.
type IPFS_ls_Params_List = capnp.StructList[IPFS_ls_Params]

// NewIPFS_ls_Params creates a new list of IPFS_ls_Params.
func NewIPFS_ls_Params_List(s *capnp.Segment, sz int32) (IPFS_ls_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_ls_Params](l), err
}

// IPFS_ls_Params_Future is a wrapper for a IPFS_ls_Params promised by a client call.
type IPFS_ls_Params_Future struct{ *capnp.Future }

func (f IPFS_ls_Params_Future) Struct() (IPFS_ls_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_ls_Params(p.Struct()), err
}

type IPFS_ls_Results capnp.Struct

// IPFS_ls_Results_TypeID is the unique identifier for the type IPFS_ls_Results.
const IPFS_ls_Results_TypeID = 0xc65336464e949b9c

func NewIPFS_ls_Results(s *capnp.Segment) (IPFS_ls_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_ls_Results(st), err
}

func NewRootIPFS_ls_Results(s *capnp.Segment) (IPFS_ls_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_ls_Results(st), err
}

func ReadRootIPFS_ls_Results(msg *capnp.Message) (IPFS_ls_Results, error) {
	root, err := msg.Root()
	return IPFS_ls_Results(root.Struct()), err
}

func (s IPFS_ls_Results) String() string {
	str, _ := text.Marshal(0xc65336464e949b9c, capnp.Struct(s))
	return str
}

func (s IPFS_ls_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_ls_Results) DecodeFromPtr(p capnp.Ptr) IPFS_ls_Results {
	return IPFS_ls_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_ls_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_ls_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_ls_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_ls_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_ls_Results) Entries() (Entry_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Entry_List(p.List()), err
}

func (s IPFS_ls_Results) HasEntries() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_ls_Results) SetEntries(v Entry_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewEntries sets the entries field to a newly
// allocated Entry_List, preferring placement in s's segment.
func (s IPFS_ls_Results) NewEntries(n int32) (Entry_List, error) {
	l, err := NewEntry_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Entry_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// IPFS_ls_Results_List is a list of IPFS_ls_Results.
type IPFS_ls_Results_List = capnp.StructList[IPFS_ls_Results]

// NewIPFS_ls_Results creates a new list of IPFS_ls_Results.
func NewIPFS_ls_Results_List(s *capnp.Segment, sz int32) (IPFS_ls_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_ls_Results](l), err
}

// IPFS_ls_Results_Future is a wrapper for a IPFS_ls_Results promised by a client call.
type IPFS_ls_Results_Future struct{ *capnp.Future }

func (f IPFS_ls_Results_Future) Struct() (IPFS_ls_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_ls_Results(p.Struct()), err
}

type IPFS_stat_Params capnp.Struct

// IPFS_stat_Params_TypeID is the unique identifier for the type IPFS_stat_Params.
const IPFS_stat_Params_TypeID = 0x8284348c17041a84

func NewIPFS_stat_Params(s *capnp.Segment) (IPFS_stat_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_stat_Params(st), err
}

func NewRootIPFS_stat_Params(s *capnp.Segment) (IPFS_stat_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_stat_Params(st), err
}

func ReadRootIPFS_stat_Params(msg *capnp.Message) (IPFS_stat_Params, error) {
	root, err := msg.Root()
	return IPFS_stat_Params(root.Struct()), err
}

func (s IPFS_stat_Params) String() string {
	str, _ := text.Marshal(0x8284348c17041a84, capnp.Struct(s))
	return str
}

func (s IPFS_stat_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_stat_Params) DecodeFromPtr(p capnp.Ptr) IPFS_stat_Params {
	return IPFS_stat_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_stat_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_stat_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_stat_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_stat_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_stat_Params) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_stat_Params) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_stat_Params) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_stat_Params) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_stat_Params_List is a list of IPFS_stat_Params.
type IPFS_stat_Params_List = capnp.StructList[IPFS_stat_Params]

// NewIPFS_stat_Params creates a new list of IPFS_stat_Params.
func NewIPFS_stat_Params_List(s *capnp.Segment, sz int32) (IPFS_stat_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_stat_Params](l), err
}

// IPFS_stat_Params_Future is a wrapper for a IPFS_stat_Params promised by a client call.
type IPFS_stat_Params_Future struct{ *capnp.Future }

func (f IPFS_stat_Params_Future) Struct() (IPFS_stat_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_stat_Params(p.Struct()), err
}

type IPFS_stat_Results capnp.Struct

// IPFS_stat_Results_TypeID is the unique identifier for the type IPFS_stat_Results.
const IPFS_stat_Results_TypeID = 0x90338670b754f0d0

func NewIPFS_stat_Results(s *capnp.Segment) (IPFS_stat_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_stat_Results(st), err
}

func NewRootIPFS_stat_Results(s *capnp.Segment) (IPFS_stat_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_stat_Results(st), err
}

func ReadRootIPFS_stat_Results(msg *capnp.Message) (IPFS_stat_Results, error) {
	root, err := msg.Root()
	return IPFS_stat_Results(root.Struct()), err
}

func (s IPFS_stat_Results) String() string {
	str, _ := text.Marshal(0x90338670b754f0d0, capnp.Struct(s))
	return str
}

func (s IPFS_stat_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_stat_Results) DecodeFromPtr(p capnp.Ptr) IPFS_stat_Results {
	return IPFS_stat_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_stat_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_stat_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_stat_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_stat_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_stat_Results) Info() (NodeInfo, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return NodeInfo(p.Struct()), err
}

func (s IPFS_stat_Results) HasInfo() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_stat_Results) SetInfo(v NodeInfo) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewInfo sets the info field to a newly
// allocated NodeInfo struct, preferring placement in s's segment.
func (s IPFS_stat_Results) NewInfo() (NodeInfo, error) {
	ss, err := NewNodeInfo(capnp.Struct(s).Segment())
	if err != nil {
		return NodeInfo{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// IPFS_stat_Results_List is a list of IPFS_stat_Results.
type IPFS_stat_Results_List = capnp.StructList[IPFS_stat_Results]

// NewIPFS_stat_Results creates a new list of IPFS_stat_Results.
func NewIPFS_stat_Results_List(s *capnp.Segment, sz int32) (IPFS_stat_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_stat_Results](l), err
}

// IPFS_stat_Results_Future is a wrapper for a IPFS_stat_Results promised by a client call.
type IPFS_stat_Results_Future struct{ *capnp.Future }

func (f IPFS_stat_Results_Future) Struct() (IPFS_stat_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_stat_Results(p.Struct()), err
}
func (p IPFS_stat_Results_Future) Info() NodeInfo_Future {
	return NodeInfo_Future{Future: p.Future.Field(0, nil)}
}

type IPFS_pin_Params capnp.Struct

// IPFS_pin_Params_TypeID is the unique identifier for the type IPFS_pin_Params.
const IPFS_pin_Params_TypeID = 0xba93d5e4aea44e63

func NewIPFS_pin_Params(s *capnp.Segment) (IPFS_pin_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_pin_Params(st), err
}

func NewRootIPFS_pin_Params(s *capnp.Segment) (IPFS_pin_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_pin_Params(st), err
}

func ReadRootIPFS_pin_Params(msg *capnp.Message) (IPFS_pin_Params, error) {
	root, err := msg.Root()
	return IPFS_pin_Params(root.Struct()), err
}

func (s IPFS_pin_Params) String() string {
	str, _ := text.Marshal(0xba93d5e4aea44e63, capnp.Struct(s))
	return str
}

func (s IPFS_pin_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_pin_Params) DecodeFromPtr(p capnp.Ptr) IPFS_pin_Params {
	return IPFS_pin_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_pin_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_pin_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_pin_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_pin_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_pin_Params) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_pin_Params) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_pin_Params) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_pin_Params) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_pin_Params_List is a list of IPFS_pin_Params.
type IPFS_pin_Params_List = capnp.StructList[IPFS_pin_Params]

// NewIPFS_pin_Params creates a new list of IPFS_pin_Params.
func NewIPFS_pin_Params_List(s *capnp.Segment, sz int32) (IPFS_pin_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_pin_Params](l), err
}

// IPFS_pin_Params_Future is a wrapper for a IPFS_pin_Params promised by a client call.
type IPFS_pin_Params_Future struct{ *capnp.Future }

func (f IPFS_pin_Params_Future) Struct() (IPFS_pin_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_pin_Params(p.Struct()), err
}

type IPFS_pin_Results capnp.Struct

// IPFS_pin_Results_TypeID is the unique identifier for the type IPFS_pin_Results.
const IPFS_pin_Results_TypeID = 0xf81b3789a4d0575d

func NewIPFS_pin_Results(s *capnp.Segment) (IPFS_pin_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_pin_Results(st), err
}

func NewRootIPFS_pin_Results(s *capnp.Segment) (IPFS_pin_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_pin_Results(st), err
}

func ReadRootIPFS_pin_Results(msg *capnp.Message) (IPFS_pin_Results, error) {
	root, err := msg.Root()
	return IPFS_pin_Results(root.Struct()), err
}

func (s IPFS_pin_Results) String() string {
	str, _ := text.Marshal(0xf81b3789a4d0575d, capnp.Struct(s))
	return str
}

func (s IPFS_pin_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_pin_Results) DecodeFromPtr(p capnp.Ptr) IPFS_pin_Results {
	return IPFS_pin_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_pin_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_pin_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_pin_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_pin_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_pin_Results) Success() bool {
	return capnp.Struct(s).Bit(0)
}

func (s IPFS_pin_Results) SetSuccess(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

// IPFS_pin_Results_List is a list of IPFS_pin_Results.
type IPFS_pin_Results_List = capnp.StructList[IPFS_pin_Results]

// NewIPFS_pin_Results creates a new list of IPFS_pin_Results.
func NewIPFS_pin_Results_List(s *capnp.Segment, sz int32) (IPFS_pin_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_pin_Results](l), err
}

// IPFS_pin_Results_Future is a wrapper for a IPFS_pin_Results promised by a client call.
type IPFS_pin_Results_Future struct{ *capnp.Future }

func (f IPFS_pin_Results_Future) Struct() (IPFS_pin_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_pin_Results(p.Struct()), err
}

type IPFS_unpin_Params capnp.Struct

// IPFS_unpin_Params_TypeID is the unique identifier for the type IPFS_unpin_Params.
const IPFS_unpin_Params_TypeID = 0x8c76ad0fbaea12d7

func NewIPFS_unpin_Params(s *capnp.Segment) (IPFS_unpin_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_unpin_Params(st), err
}

func NewRootIPFS_unpin_Params(s *capnp.Segment) (IPFS_unpin_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_unpin_Params(st), err
}

func ReadRootIPFS_unpin_Params(msg *capnp.Message) (IPFS_unpin_Params, error) {
	root, err := msg.Root()
	return IPFS_unpin_Params(root.Struct()), err
}

func (s IPFS_unpin_Params) String() string {
	str, _ := text.Marshal(0x8c76ad0fbaea12d7, capnp.Struct(s))
	return str
}

func (s IPFS_unpin_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_unpin_Params) DecodeFromPtr(p capnp.Ptr) IPFS_unpin_Params {
	return IPFS_unpin_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_unpin_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_unpin_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_unpin_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_unpin_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_unpin_Params) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_unpin_Params) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_unpin_Params) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_unpin_Params) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_unpin_Params_List is a list of IPFS_unpin_Params.
type IPFS_unpin_Params_List = capnp.StructList[IPFS_unpin_Params]

// NewIPFS_unpin_Params creates a new list of IPFS_unpin_Params.
func NewIPFS_unpin_Params_List(s *capnp.Segment, sz int32) (IPFS_unpin_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_unpin_Params](l), err
}

// IPFS_unpin_Params_Future is a wrapper for a IPFS_unpin_Params promised by a client call.
type IPFS_unpin_Params_Future struct{ *capnp.Future }

func (f IPFS_unpin_Params_Future) Struct() (IPFS_unpin_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_unpin_Params(p.Struct()), err
}

type IPFS_unpin_Results capnp.Struct

// IPFS_unpin_Results_TypeID is the unique identifier for the type IPFS_unpin_Results.
const IPFS_unpin_Results_TypeID = 0xa72dee615d5bbb87

func NewIPFS_unpin_Results(s *capnp.Segment) (IPFS_unpin_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_unpin_Results(st), err
}

func NewRootIPFS_unpin_Results(s *capnp.Segment) (IPFS_unpin_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_unpin_Results(st), err
}

func ReadRootIPFS_unpin_Results(msg *capnp.Message) (IPFS_unpin_Results, error) {
	root, err := msg.Root()
	return IPFS_unpin_Results(root.Struct()), err
}

func (s IPFS_unpin_Results) String() string {
	str, _ := text.Marshal(0xa72dee615d5bbb87, capnp.Struct(s))
	return str
}

func (s IPFS_unpin_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_unpin_Results) DecodeFromPtr(p capnp.Ptr) IPFS_unpin_Results {
	return IPFS_unpin_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_unpin_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_unpin_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_unpin_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_unpin_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_unpin_Results) Success() bool {
	return capnp.Struct(s).Bit(0)
}

func (s IPFS_unpin_Results) SetSuccess(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

// IPFS_unpin_Results_List is a list of IPFS_unpin_Results.
type IPFS_unpin_Results_List = capnp.StructList[IPFS_unpin_Results]

// NewIPFS_unpin_Results creates a new list of IPFS_unpin_Results.
func NewIPFS_unpin_Results_List(s *capnp.Segment, sz int32) (IPFS_unpin_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_unpin_Results](l), err
}

// IPFS_unpin_Results_Future is a wrapper for a IPFS_unpin_Results promised by a client call.
type IPFS_unpin_Results_Future struct{ *capnp.Future }

func (f IPFS_unpin_Results_Future) Struct() (IPFS_unpin_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_unpin_Results(p.Struct()), err
}

type IPFS_pins_Params capnp.Struct

// IPFS_pins_Params_TypeID is the unique identifier for the type IPFS_pins_Params.
const IPFS_pins_Params_TypeID = 0xe798bea7bc0cc0ea

func NewIPFS_pins_Params(s *capnp.Segment) (IPFS_pins_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_pins_Params(st), err
}

func NewRootIPFS_pins_Params(s *capnp.Segment) (IPFS_pins_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_pins_Params(st), err
}

func ReadRootIPFS_pins_Params(msg *capnp.Message) (IPFS_pins_Params, error) {
	root, err := msg.Root()
	return IPFS_pins_Params(root.Struct()), err
}

func (s IPFS_pins_Params) String() string {
	str, _ := text.Marshal(0xe798bea7bc0cc0ea, capnp.Struct(s))
	return str
}

func (s IPFS_pins_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_pins_Params) DecodeFromPtr(p capnp.Ptr) IPFS_pins_Params {
	return IPFS_pins_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_pins_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_pins_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_pins_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_pins_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// IPFS_pins_Params_List is a list of IPFS_pins_Params.
type IPFS_pins_Params_List = capnp.StructList[IPFS_pins_Params]

// NewIPFS_pins_Params creates a new list of IPFS_pins_Params.
func NewIPFS_pins_Params_List(s *capnp.Segment, sz int32) (IPFS_pins_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_pins_Params](l), err
}

// IPFS_pins_Params_Future is a wrapper for a IPFS_pins_Params promised by a client call.
type IPFS_pins_Params_Future struct{ *capnp.Future }

func (f IPFS_pins_Params_Future) Struct() (IPFS_pins_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_pins_Params(p.Struct()), err
}

type IPFS_pins_Results capnp.Struct

// IPFS_pins_Results_TypeID is the unique identifier for the type IPFS_pins_Results.
const IPFS_pins_Results_TypeID = 0xe0f22a608a7c6e22

func NewIPFS_pins_Results(s *capnp.Segment) (IPFS_pins_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_pins_Results(st), err
}

func NewRootIPFS_pins_Results(s *capnp.Segment) (IPFS_pins_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_pins_Results(st), err
}

func ReadRootIPFS_pins_Results(msg *capnp.Message) (IPFS_pins_Results, error) {
	root, err := msg.Root()
	return IPFS_pins_Results(root.Struct()), err
}

func (s IPFS_pins_Results) String() string {
	str, _ := text.Marshal(0xe0f22a608a7c6e22, capnp.Struct(s))
	return str
}

func (s IPFS_pins_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_pins_Results) DecodeFromPtr(p capnp.Ptr) IPFS_pins_Results {
	return IPFS_pins_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_pins_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_pins_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_pins_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_pins_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_pins_Results) Cids() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s IPFS_pins_Results) HasCids() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_pins_Results) SetCids(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewCids sets the cids field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s IPFS_pins_Results) NewCids(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// IPFS_pins_Results_List is a list of IPFS_pins_Results.
type IPFS_pins_Results_List = capnp.StructList[IPFS_pins_Results]

// NewIPFS_pins_Results creates a new list of IPFS_pins_Results.
func NewIPFS_pins_Results_List(s *capnp.Segment, sz int32) (IPFS_pins_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_pins_Results](l), err
}

// IPFS_pins_Results_Future is a wrapper for a IPFS_pins_Results promised by a client call.
type IPFS_pins_Results_Future struct{ *capnp.Future }

func (f IPFS_pins_Results_Future) Struct() (IPFS_pins_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_pins_Results(p.Struct()), err
}

type IPFS_id_Params capnp.Struct

// IPFS_id_Params_TypeID is the unique identifier for the type IPFS_id_Params.
const IPFS_id_Params_TypeID = 0xb7e699451c43a067

func NewIPFS_id_Params(s *capnp.Segment) (IPFS_id_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_id_Params(st), err
}

func NewRootIPFS_id_Params(s *capnp.Segment) (IPFS_id_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_id_Params(st), err
}

func ReadRootIPFS_id_Params(msg *capnp.Message) (IPFS_id_Params, error) {
	root, err := msg.Root()
	return IPFS_id_Params(root.Struct()), err
}

func (s IPFS_id_Params) String() string {
	str, _ := text.Marshal(0xb7e699451c43a067, capnp.Struct(s))
	return str
}

func (s IPFS_id_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_id_Params) DecodeFromPtr(p capnp.Ptr) IPFS_id_Params {
	return IPFS_id_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_id_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_id_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_id_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_id_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// IPFS_id_Params_List is a list of IPFS_id_Params.
type IPFS_id_Params_List = capnp.StructList[IPFS_id_Params]

// NewIPFS_id_Params creates a new list of IPFS_id_Params.
func NewIPFS_id_Params_List(s *capnp.Segment, sz int32) (IPFS_id_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_id_Params](l), err
}

// IPFS_id_Params_Future is a wrapper for a IPFS_id_Params promised by a client call.
type IPFS_id_Params_Future struct{ *capnp.Future }

func (f IPFS_id_Params_Future) Struct() (IPFS_id_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_id_Params(p.Struct()), err
}

type IPFS_id_Results capnp.Struct

// IPFS_id_Results_TypeID is the unique identifier for the type IPFS_id_Results.
const IPFS_id_Results_TypeID = 0xf469f437c0bfc104

func NewIPFS_id_Results(s *capnp.Segment) (IPFS_id_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_id_Results(st), err
}

func NewRootIPFS_id_Results(s *capnp.Segment) (IPFS_id_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_id_Results(st), err
}

func ReadRootIPFS_id_Results(msg *capnp.Message) (IPFS_id_Results, error) {
	root, err := msg.Root()
	return IPFS_id_Results(root.Struct()), err
}

func (s IPFS_id_Results) String() string {
	str, _ := text.Marshal(0xf469f437c0bfc104, capnp.Struct(s))
	return str
}

func (s IPFS_id_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_id_Results) DecodeFromPtr(p capnp.Ptr) IPFS_id_Results {
	return IPFS_id_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_id_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_id_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_id_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_id_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_id_Results) PeerInfo() (PeerInfo, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return PeerInfo(p.Struct()), err
}

func (s IPFS_id_Results) HasPeerInfo() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_id_Results) SetPeerInfo(v PeerInfo) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewPeerInfo sets the peerInfo field to a newly
// allocated PeerInfo struct, preferring placement in s's segment.
func (s IPFS_id_Results) NewPeerInfo() (PeerInfo, error) {
	ss, err := NewPeerInfo(capnp.Struct(s).Segment())
	if err != nil {
		return PeerInfo{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// IPFS_id_Results_List is a list of IPFS_id_Results.
type IPFS_id_Results_List = capnp.StructList[IPFS_id_Results]

// NewIPFS_id_Results creates a new list of IPFS_id_Results.
func NewIPFS_id_Results_List(s *capnp.Segment, sz int32) (IPFS_id_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_id_Results](l), err
}

// IPFS_id_Results_Future is a wrapper for a IPFS_id_Results promised by a client call.
type IPFS_id_Results_Future struct{ *capnp.Future }

func (f IPFS_id_Results_Future) Struct() (IPFS_id_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_id_Results(p.Struct()), err
}
func (p IPFS_id_Results_Future) PeerInfo() PeerInfo_Future {
	return PeerInfo_Future{Future: p.Future.Field(0, nil)}
}

type IPFS_connect_Params capnp.Struct

// IPFS_connect_Params_TypeID is the unique identifier for the type IPFS_connect_Params.
const IPFS_connect_Params_TypeID = 0xadae6334690b6b6f

func NewIPFS_connect_Params(s *capnp.Segment) (IPFS_connect_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_connect_Params(st), err
}

func NewRootIPFS_connect_Params(s *capnp.Segment) (IPFS_connect_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_connect_Params(st), err
}

func ReadRootIPFS_connect_Params(msg *capnp.Message) (IPFS_connect_Params, error) {
	root, err := msg.Root()
	return IPFS_connect_Params(root.Struct()), err
}

func (s IPFS_connect_Params) String() string {
	str, _ := text.Marshal(0xadae6334690b6b6f, capnp.Struct(s))
	return str
}

func (s IPFS_connect_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_connect_Params) DecodeFromPtr(p capnp.Ptr) IPFS_connect_Params {
	return IPFS_connect_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_connect_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_connect_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_connect_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_connect_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_connect_Params) Addr() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s IPFS_connect_Params) HasAddr() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_connect_Params) AddrBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s IPFS_connect_Params) SetAddr(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// IPFS_connect_Params_List is a list of IPFS_connect_Params.
type IPFS_connect_Params_List = capnp.StructList[IPFS_connect_Params]

// NewIPFS_connect_Params creates a new list of IPFS_connect_Params.
func NewIPFS_connect_Params_List(s *capnp.Segment, sz int32) (IPFS_connect_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_connect_Params](l), err
}

// IPFS_connect_Params_Future is a wrapper for a IPFS_connect_Params promised by a client call.
type IPFS_connect_Params_Future struct{ *capnp.Future }

func (f IPFS_connect_Params_Future) Struct() (IPFS_connect_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_connect_Params(p.Struct()), err
}

type IPFS_connect_Results capnp.Struct

// IPFS_connect_Results_TypeID is the unique identifier for the type IPFS_connect_Results.
const IPFS_connect_Results_TypeID = 0xc5fe3a2c8650ed19

func NewIPFS_connect_Results(s *capnp.Segment) (IPFS_connect_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_connect_Results(st), err
}

func NewRootIPFS_connect_Results(s *capnp.Segment) (IPFS_connect_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return IPFS_connect_Results(st), err
}

func ReadRootIPFS_connect_Results(msg *capnp.Message) (IPFS_connect_Results, error) {
	root, err := msg.Root()
	return IPFS_connect_Results(root.Struct()), err
}

func (s IPFS_connect_Results) String() string {
	str, _ := text.Marshal(0xc5fe3a2c8650ed19, capnp.Struct(s))
	return str
}

func (s IPFS_connect_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_connect_Results) DecodeFromPtr(p capnp.Ptr) IPFS_connect_Results {
	return IPFS_connect_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_connect_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_connect_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_connect_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_connect_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_connect_Results) Success() bool {
	return capnp.Struct(s).Bit(0)
}

func (s IPFS_connect_Results) SetSuccess(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

// IPFS_connect_Results_List is a list of IPFS_connect_Results.
type IPFS_connect_Results_List = capnp.StructList[IPFS_connect_Results]

// NewIPFS_connect_Results creates a new list of IPFS_connect_Results.
func NewIPFS_connect_Results_List(s *capnp.Segment, sz int32) (IPFS_connect_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_connect_Results](l), err
}

// IPFS_connect_Results_Future is a wrapper for a IPFS_connect_Results promised by a client call.
type IPFS_connect_Results_Future struct{ *capnp.Future }

func (f IPFS_connect_Results_Future) Struct() (IPFS_connect_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_connect_Results(p.Struct()), err
}

type IPFS_peers_Params capnp.Struct

// IPFS_peers_Params_TypeID is the unique identifier for the type IPFS_peers_Params.
const IPFS_peers_Params_TypeID = 0xdbc8c8183207fc9c

func NewIPFS_peers_Params(s *capnp.Segment) (IPFS_peers_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_peers_Params(st), err
}

func NewRootIPFS_peers_Params(s *capnp.Segment) (IPFS_peers_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return IPFS_peers_Params(st), err
}

func ReadRootIPFS_peers_Params(msg *capnp.Message) (IPFS_peers_Params, error) {
	root, err := msg.Root()
	return IPFS_peers_Params(root.Struct()), err
}

func (s IPFS_peers_Params) String() string {
	str, _ := text.Marshal(0xdbc8c8183207fc9c, capnp.Struct(s))
	return str
}

func (s IPFS_peers_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_peers_Params) DecodeFromPtr(p capnp.Ptr) IPFS_peers_Params {
	return IPFS_peers_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_peers_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_peers_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_peers_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_peers_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// IPFS_peers_Params_List is a list of IPFS_peers_Params.
type IPFS_peers_Params_List = capnp.StructList[IPFS_peers_Params]

// NewIPFS_peers_Params creates a new list of IPFS_peers_Params.
func NewIPFS_peers_Params_List(s *capnp.Segment, sz int32) (IPFS_peers_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[IPFS_peers_Params](l), err
}

// IPFS_peers_Params_Future is a wrapper for a IPFS_peers_Params promised by a client call.
type IPFS_peers_Params_Future struct{ *capnp.Future }

func (f IPFS_peers_Params_Future) Struct() (IPFS_peers_Params, error) {
	p, err := f.Future.Ptr()
	return IPFS_peers_Params(p.Struct()), err
}

type IPFS_peers_Results capnp.Struct

// IPFS_peers_Results_TypeID is the unique identifier for the type IPFS_peers_Results.
const IPFS_peers_Results_TypeID = 0x8e86d1c015472327

func NewIPFS_peers_Results(s *capnp.Segment) (IPFS_peers_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_peers_Results(st), err
}

func NewRootIPFS_peers_Results(s *capnp.Segment) (IPFS_peers_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return IPFS_peers_Results(st), err
}

func ReadRootIPFS_peers_Results(msg *capnp.Message) (IPFS_peers_Results, error) {
	root, err := msg.Root()
	return IPFS_peers_Results(root.Struct()), err
}

func (s IPFS_peers_Results) String() string {
	str, _ := text.Marshal(0x8e86d1c015472327, capnp.Struct(s))
	return str
}

func (s IPFS_peers_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (IPFS_peers_Results) DecodeFromPtr(p capnp.Ptr) IPFS_peers_Results {
	return IPFS_peers_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s IPFS_peers_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s IPFS_peers_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s IPFS_peers_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s IPFS_peers_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s IPFS_peers_Results) PeerList() (PeerInfo_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return PeerInfo_List(p.List()), err
}

func (s IPFS_peers_Results) HasPeerList() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s IPFS_peers_Results) SetPeerList(v PeerInfo_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewPeerList sets the peerList field to a newly
// allocated PeerInfo_List, preferring placement in s's segment.
func (s IPFS_peers_Results) NewPeerList(n int32) (PeerInfo_List, error) {
	l, err := NewPeerInfo_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return PeerInfo_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// IPFS_peers_Results_List is a list of IPFS_peers_Results.
type IPFS_peers_Results_List = capnp.StructList[IPFS_peers_Results]

// NewIPFS_peers_Results creates a new list of IPFS_peers_Results.
func NewIPFS_peers_Results_List(s *capnp.Segment, sz int32) (IPFS_peers_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[IPFS_peers_Results](l), err
}

// IPFS_peers_Results_Future is a wrapper for a IPFS_peers_Results promised by a client call.
type IPFS_peers_Results_Future struct{ *capnp.Future }

func (f IPFS_peers_Results_Future) Struct() (IPFS_peers_Results, error) {
	p, err := f.Future.Ptr()
	return IPFS_peers_Results(p.Struct()), err
}

type Entry capnp.Struct

// Entry_TypeID is the unique identifier for the type Entry.
const Entry_TypeID = 0xe50956368ed67ecf

func NewEntry(s *capnp.Segment) (Entry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Entry(st), err
}

func NewRootEntry(s *capnp.Segment) (Entry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2})
	return Entry(st), err
}

func ReadRootEntry(msg *capnp.Message) (Entry, error) {
	root, err := msg.Root()
	return Entry(root.Struct()), err
}

func (s Entry) String() string {
	str, _ := text.Marshal(0xe50956368ed67ecf, capnp.Struct(s))
	return str
}

func (s Entry) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Entry) DecodeFromPtr(p capnp.Ptr) Entry {
	return Entry(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Entry) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Entry) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Entry) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Entry) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Entry) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Entry) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Entry) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Entry) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Entry) Type() EntryType {
	return EntryType(capnp.Struct(s).Uint16(0))
}

func (s Entry) SetType(v EntryType) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s Entry) Size() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s Entry) SetSize(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s Entry) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Entry) HasCid() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Entry) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Entry) SetCid(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Entry_List is a list of Entry.
type Entry_List = capnp.StructList[Entry]

// NewEntry creates a new list of Entry.
func NewEntry_List(s *capnp.Segment, sz int32) (Entry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 2}, sz)
	return capnp.StructList[Entry](l), err
}

// Entry_Future is a wrapper for a Entry promised by a client call.
type Entry_Future struct{ *capnp.Future }

func (f Entry_Future) Struct() (Entry, error) {
	p, err := f.Future.Ptr()
	return Entry(p.Struct()), err
}

type EntryType uint16

// EntryType_TypeID is the unique identifier for the type EntryType.
const EntryType_TypeID = 0x84f03db984574d8a

// Values of EntryType.
const (
	EntryType_file      EntryType = 0
	EntryType_directory EntryType = 1
	EntryType_symlink   EntryType = 2
)

// String returns the enum's constant name.
func (c EntryType) String() string {
	switch c {
	case EntryType_file:
		return "file"
	case EntryType_directory:
		return "directory"
	case EntryType_symlink:
		return "symlink"

	default:
		return ""
	}
}

// EntryTypeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func EntryTypeFromString(c string) EntryType {
	switch c {
	case "file":
		return EntryType_file
	case "directory":
		return EntryType_directory
	case "symlink":
		return EntryType_symlink

	default:
		return 0
	}
}

type EntryType_List = capnp.EnumList[EntryType]

func NewEntryType_List(s *capnp.Segment, sz int32) (EntryType_List, error) {
	return capnp.NewEnumList[EntryType](s, sz)
}

type NodeInfo capnp.Struct

// NodeInfo_TypeID is the unique identifier for the type NodeInfo.
const NodeInfo_TypeID = 0xa83fd4abe6553705

func NewNodeInfo(s *capnp.Segment) (NodeInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3})
	return NodeInfo(st), err
}

func NewRootNodeInfo(s *capnp.Segment) (NodeInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3})
	return NodeInfo(st), err
}

func ReadRootNodeInfo(msg *capnp.Message) (NodeInfo, error) {
	root, err := msg.Root()
	return NodeInfo(root.Struct()), err
}

func (s NodeInfo) String() string {
	str, _ := text.Marshal(0xa83fd4abe6553705, capnp.Struct(s))
	return str
}

func (s NodeInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (NodeInfo) DecodeFromPtr(p capnp.Ptr) NodeInfo {
	return NodeInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s NodeInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s NodeInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s NodeInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s NodeInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s NodeInfo) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s NodeInfo) HasCid() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s NodeInfo) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s NodeInfo) SetCid(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s NodeInfo) Size() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s NodeInfo) SetSize(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s NodeInfo) CumulativeSize() uint64 {
	return capnp.Struct(s).Uint64(8)
}

func (s NodeInfo) SetCumulativeSize(v uint64) {
	capnp.Struct(s).SetUint64(8, v)
}

func (s NodeInfo) Type() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s NodeInfo) HasType() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s NodeInfo) TypeBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s NodeInfo) SetType(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s NodeInfo) Links() (Link_List, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Link_List(p.List()), err
}

func (s NodeInfo) HasLinks() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s NodeInfo) SetLinks(v Link_List) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewLinks sets the links field to a newly
// allocated Link_List, preferring placement in s's segment.
func (s NodeInfo) NewLinks(n int32) (Link_List, error) {
	l, err := NewLink_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Link_List{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// NodeInfo_List is a list of NodeInfo.
type NodeInfo_List = capnp.StructList[NodeInfo]

// NewNodeInfo creates a new list of NodeInfo.
func NewNodeInfo_List(s *capnp.Segment, sz int32) (NodeInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 3}, sz)
	return capnp.StructList[NodeInfo](l), err
}

// NodeInfo_Future is a wrapper for a NodeInfo promised by a client call.
type NodeInfo_Future struct{ *capnp.Future }

func (f NodeInfo_Future) Struct() (NodeInfo, error) {
	p, err := f.Future.Ptr()
	return NodeInfo(p.Struct()), err
}

type Link capnp.Struct

// Link_TypeID is the unique identifier for the type Link.
const Link_TypeID = 0xe6d3c322caf5dd4b

func NewLink(s *capnp.Segment) (Link, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Link(st), err
}

func NewRootLink(s *capnp.Segment) (Link, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Link(st), err
}

func ReadRootLink(msg *capnp.Message) (Link, error) {
	root, err := msg.Root()
	return Link(root.Struct()), err
}

func (s Link) String() string {
	str, _ := text.Marshal(0xe6d3c322caf5dd4b, capnp.Struct(s))
	return str
}

func (s Link) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Link) DecodeFromPtr(p capnp.Ptr) Link {
	return Link(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Link) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Link) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Link) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Link) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Link) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Link) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Link) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Link) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Link) Size() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s Link) SetSize(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s Link) Cid() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Link) HasCid() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Link) CidBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Link) SetCid(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Link_List is a list of Link.
type Link_List = capnp.StructList[Link]

// NewLink creates a new list of Link.
func NewLink_List(s *capnp.Segment, sz int32) (Link_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Link](l), err
}

// Link_Future is a wrapper for a Link promised by a client call.
type Link_Future struct{ *capnp.Future }

func (f Link_Future) Struct() (Link, error) {
	p, err := f.Future.Ptr()
	return Link(p.Struct()), err
}

type PeerInfo capnp.Struct

// PeerInfo_TypeID is the unique identifier for the type PeerInfo.
const PeerInfo_TypeID = 0xa06f294430ac72ff

func NewPeerInfo(s *capnp.Segment) (PeerInfo, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return PeerInfo(st), err
}

func NewRootPeerInfo(s *capnp.Segment) (PeerInfo, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3})
	return PeerInfo(st), err
}

func ReadRootPeerInfo(msg *capnp.Message) (PeerInfo, error) {
	root, err := msg.Root()
	return PeerInfo(root.Struct()), err
}

func (s PeerInfo) String() string {
	str, _ := text.Marshal(0xa06f294430ac72ff, capnp.Struct(s))
	return str
}

func (s PeerInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (PeerInfo) DecodeFromPtr(p capnp.Ptr) PeerInfo {
	return PeerInfo(capnp.Struct{}.DecodeFromPtr(p))
}

func (s PeerInfo) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s PeerInfo) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s PeerInfo) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s PeerInfo) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s PeerInfo) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s PeerInfo) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s PeerInfo) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s PeerInfo) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s PeerInfo) Addresses() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s PeerInfo) HasAddresses() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s PeerInfo) SetAddresses(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewAddresses sets the addresses field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s PeerInfo) NewAddresses(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s PeerInfo) Protocols() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return capnp.TextList(p.List()), err
}

func (s PeerInfo) HasProtocols() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s PeerInfo) SetProtocols(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(2, v.ToPtr())
}

// NewProtocols sets the protocols field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s PeerInfo) NewProtocols(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(2, l.ToPtr())
	return l, err
}

// PeerInfo_List is a list of PeerInfo.
type PeerInfo_List = capnp.StructList[PeerInfo]

// NewPeerInfo creates a new list of PeerInfo.
func NewPeerInfo_List(s *capnp.Segment, sz int32) (PeerInfo_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 3}, sz)
	return capnp.StructList[PeerInfo](l), err
}

// PeerInfo_Future is a wrapper for a PeerInfo promised by a client call.
type PeerInfo_Future struct{ *capnp.Future }

func (f PeerInfo_Future) Struct() (PeerInfo, error) {
	p, err := f.Future.Ptr()
	return PeerInfo(p.Struct()), err
}

const schema_da965b22da734daf = "x\xda\xacV{l\x14\xd5\x17>\xe7\xceNgw\x7f" +
	"\xbb\xbf\xed\xed\xb4\x91\x87dc)\x01\x1a \xbc\x0a\x82" +
	"!\xbb\"\xa0\x05\x8a;-H\x10Q\xc6\x9dA&l" +
	"g\xd7\x9d)aI\xa1\xc1\x94g\x90\x00\x02\x11\x1f\x09" +
	"&D\x08Z\x88\x10C\x8a\xa2%\x06%\xfa\x87\x10\x01" +
	"\x03\x86\xa8\x84G$\xd1\x10\x02\xc6\xa08\xe6N;\xb3" +
	"\xd3e\xb7\x84\xe8\x7f\x939\xe7~\xf7\x9c\xef<\xee7" +
	":\xee\x8b\xfb\xc6\x84\xe7\x07\x81H+\xf82\xab}\x80" +
	"\xef\x91\xcd\xe3\xdb_\x03Z\x81\x00<\x0a\x00\"\xe5o" +
	"\x01\x8aU|\x0c\xd0\xda\xd40\xbf\xbds\xca\xcdv\xa0" +
	"ab\x1dj0.V/\xdcu\x11\x00\xc5:\xfe\x98" +
	"8\x85g\xee\x93\xf8g\x01\xad\xef+n\x1c\x8bt," +
	"\xdf\xec\x05\x92\xf8\xbb\x80\xe2<\x1bh\xe8\xe0\xa7\xab\xba" +
	"\xce\xac\xdb\xe2\xb1\x8fk\xe1\x09\x02\x8a9\xdb\xe1\xf4\xcd" +
	"\xb9G3\xeb\xc6m\xf5\x02t\xd8\x00\x1f\xd9v+\xfb" +
	"\xe1\xe8i\xc3\xd3{\x80\x861\x1f\x09\xcf1\xbf3\xfc" +
	"a\xf1\x82\x1d\xcc9\xfe\x10\xa0\xb5\xfe\x93\x85\x8b\xe4\xdf" +
	"F\xee\x03\xa9\x02\x11\xc0\xc7.\xdbYf_\xb6\xbb\x8c" +
	"\x81\xf1\x13\xe7]\xfb\xe0ll?Ha$\x85h\x9d" +
	"e\x87\xc5\x13e\xec\xcc\xf1\xb2(\x02Z\x83\xad\xdfI" +
	"l\xe0\x8f\x07\xbc\xa1\xfd,\\\x06\x14\xaf\x0a\x0c\xed\xca" +
	"W\xc7\x07\xb7\x1c<\xd0\xe1\xb5\xf3\xfe\x1b\x80b\xc0\xcf" +
	"\xec\xe9e\xff\xd3\xc6'\x0fz\xed\xe3\x86\xfb\x83,\x9c" +
	"1\xb6\xc3+{\x9ezt\xfa\xeekG\xbb\x1d|6" +
	"w\xfe\xcb\xe0\xb3\x92s\xf6\x1e\xbcr\xee\x8dc^\xe4" +
	":\x1by\x92}\xb0\xff\xaf\x89u#&\xff}\xd2\x9b" +
	"\xe8\x02\x7f\x05C\x96m\x87w\xde\xde1g\xc6\x84\xa6" +
	"/\xbd\x00kl\x80\xb5\xb6}\x82\xf9~+\xbfk\xf2" +
	"7^\xfb\xc7~V\xffN\xdb\xfe\xe2\xe3]\x7ff\xda" +
	"g\x9e\xf5\xda/\xd8\xe7/1\xfb\xbd#u\xcf\xbf;" +
	"\xa2\xeb\xbc\xc7z\xcf>\x8d\x01\xfb\xf6\xbf\x84\xb1\xfdN" +
	"\x9d\xfa\xc1\x93\xd7c\x81\xbb\xe0\xb3\xaa\xf5\xd6M\x8bk" +
	"o\xfd\xd4\x8b\xb1\x00+v\xc0>\xf8\xed\xea\xf3[&" +
	"<\x17\xb8ZX\x1fb7\\\xe0-\xf1\xc9\x00\xfb\x9a" +
	"\x12\xb8\x0eh\xcd\xbat\xe7\xeb\xea/\xbe\xbb\xc6\x9c\xb1" +
	"\xd0\x99\x06\xb7\x8b\xfd\x83\xec\xab*\xc8Z\xe3FW\xe8" +
	"\xd3}\x9f\xbdy\xdd\x13RG\xf0\x16\xf8\xacY\x83\x9e" +
	"\x18J^Z}\x13h\x98\xeb\xd5\xe9\xdb\x82\xdb\xc5\xdd" +
	"A\xbb\x85\x82\xeb\x898$$\x00X\xbe\x13\x9fwM" +
	"\xbc\xad\xdd\xf6&\x10\x0e1^h\x88%\xb0h\xfe\xe9" +
	"\xbd\x1b'\x0e\xfc\xc3S\x18\xb1.\xc4\x98\x99\x14\x8a\xc1" +
	"H\xcb\xc8\x19\xa6\xda<*I\xe4\x8c\x9e\x99\\\x9f\x98" +
	"\xd14\xca0e\xb3&\x11\x95\xb3r\xb3!\xf98\x1f" +
	"\x80\x0f\x01h\xb8\x1a@\xf2s(U\x12\x14\x92\x9a\x82" +
	"! \x18\x02t!\xd0\x86\x98\xae\x9b\xb1lnn." +
	"\xa3&\x10\xa5\x10\x12\x00:\xa8\x16\x00\x91V5\x02 " +
	"\xa1t*@d\x89\x96R-E\xcb\xaaI3\x9d\x05" +
	"\xcc\xb5\x19\xb9\xe6\x94\xa6/+\x16P\x8b\x9e\xd1\xf4\x9a" +
	"X\xe2\xa1#\xe2\xf2\x18\x19U\xcd\x1a5\x8d\xaa\xd1\x92" +
	"2\x0d\xf0\x82\xcc\x04\x90B\x1cJ\xc3\x08Z\xcck\xb6" +
	"f\x98\x00\x80\xff\x07Lp\x88\xe5\xf9\x81\x07d?K" +
	"R\xd6\x18\xebF\xf7\x82\xd7\xe6#\x8ch\xfa\x924\x96" +
	"\xe7G\x1e\x10\xcb\xef\xa3/\xa1\xaa\xd1l\xbd\xbe$m" +
	"\xb3\xe7\x02M\x1f\x00 \xc59\x94f\x13\xa4\x88\x95\xac" +
	"\x96\xb4\xbe\x11@z\x86CI!H\x09\xa9\xb4\xb9\x96" +
	"\xd9\xcf\xc5\x1cJ\xad\x049\x0f'\xb2\xa2dU\xc3P" +
	"\x01\x0d'5fb\x09e\xb2i3\x9dL\xa7\x8a\x98" +
	"\x8a0\xd9]\x8dbLN\xcd'\xdbf\xb4$\x93\xaa" +
	"a \x02A\xbc/\xcb9i%\xaa:YV\xba\x08" +
	"\xabXAWp(\xb5\x13t\x92\\\xc3(l\xe5P" +
	"\xda\xc0\x92\xc4\xee$\xd7\xae\x04\x90\xda9\x94\xb6\x12\xa4" +
	"\x1cV\"\x07@_g\x9e\x1b8\x94v\x10\xa4>R" +
	"\x89>\x00\xbam,\x80\xb4\x99Ci\x7f\xef\x1e\x89\x18" +
	"\xdaJ\x15\x03@0\x00h%[\x9a[R\xb2\xa9A" +
	"l\xb9\xda\xe41D\xcc\\Fu\x8eDY\x7f\x1a\xf9" +
	"\xbep\xc7\xbdt_\xa4\x8c\x9a\x84\x9c\x15\x0a\xda\xd6\xdb" +
	"\x14\x19\xd9\\z_\xdfz\x10\x92l\x16\xe5\xc8\xbf\xe8" +
	"\xfcdZ\xd7\xd5$Ca \x00\xa5\"a\x0d\xd2W" +
	"$\x9a\xe2\xe4R\xcc\xcaz\xe2\xbf\x89\xb3\xbb\xb3\xd0x" +
	"\xd8\xce\xeaM{\xa3jD\x0a\x87\xd1A\xa9!\xd8\xa6" +
	"\xeafVS=\xd5t7}\xe9j\xb2Z4\xaa\xd1" +
	">\x87\xfc\xe5\xb4\x92\xc30\x10\x0c\x17\xc7\x90\x15\xa5\x18" +
	"O^\x08E6\xe5\x07A\x14\x0b\xe3A\\\x93\xc2m" +
	"\xd8\xb3QK\x94\xd3\xe8s\xa1\xd5\x10\x8c$5\xa5\xe4" +
	"\xc2p\x1f\x03.\x9bcC^\xeeB\xc8\x0c\xe2\x05\x0e" +
	"\xa5\xa5\xf9!Wk{\x96V\xca3\xe4\x1a\xfb\xa9p" +
	"(e<C\xde\xcc\xb2\\\xca\xa1d\x12\x8c\xe8r\xb3" +
	";\x9d\xdd\xa3\x1a\xc9\x0bE@\x8c\x14\xccy\x1f\xcf\xd6" +
	"lM\xc7e\x05;\xb76\xbfs\xdd\x95\xcb\xfeM\xe3" +
	"PJx\x02m\xa8\xee\xd9\xc3s\x0bcz\xe0\xe5\x85" +
	"\x94\xf7<\xbb\x05\xc1\xd5'f`\x13\x0bn\x18\xc7\x03" +
	"\xb8Z\x08\x8f@\xb7\xea\x11\xc7`5\x10q\x08\x0a\x98" +
	"\x17\x81\xe8H*\xb1\xbfm\x0d\xa3\x80\xc4\x95\x90\xe8\x08" +
	"2\x11q\x00\x10zG@\xce\x15\xe1\xe8h`\xfaK" +
	"-\x10zI\xc0\xbc\x02DGQ\xd03\xd5@\xe8I" +
	"\x01yWs\xa3\xa3wi\xe7X \xb4C\xc02W" +
	"\xe7\xa0#\xb5\xe8{\x0cs\xa7\x80\x82+7\xd1Q1" +
	"t#\x8be\x95\x80~W\xab\xa2#-\xe9\xabS\x81" +
	"PU\xc0\x80+\xe7\xd0\x11\xf3t\x01\xbb\xafA\x10d" +
	"E\x89\xa3\x90\x94\xcd8r)#\x8e\x11\xf62\xc7Q" +
	"\xc8hz\x1c\xa3\xf6\xd3\x15\xc7\x08\xa3:\xce^\xc78" +
	"\xb6\xf5\xac\x9d8F\xed\xa1\x88c\x02K\xad\xbfb;" +
	"\xc5Q\x0f\xfdz\xd4\x03{\xd4\x98z\xe8-\x1b\xcaK" +
	"\x96\xbc\xe8$\xf7\xb1\xee\xfe\x09\x00\x00\xff\xff\xc4\xfa>" +
	"p"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_da965b22da734daf,
		Nodes: []uint64{
			0x8284348c17041a84,
			0x84f03db984574d8a,
			0x8c76ad0fbaea12d7,
			0x8e86d1c015472327,
			0x90338670b754f0d0,
			0xa06f294430ac72ff,
			0xa72dee615d5bbb87,
			0xa83fd4abe6553705,
			0xaadf1b3f02f6ff23,
			0xadaaae7523bdc7e4,
			0xadae6334690b6b6f,
			0xb7e699451c43a067,
			0xba93d5e4aea44e63,
			0xc5fe3a2c8650ed19,
			0xc65336464e949b9c,
			0xcb3a96057ca67436,
			0xd44a8470fbc0385e,
			0xd6c02c9d5a3500b3,
			0xdbc8c8183207fc9c,
			0xe0f22a608a7c6e22,
			0xe50956368ed67ecf,
			0xe6d3c322caf5dd4b,
			0xe798bea7bc0cc0ea,
			0xf07e5f02273b1d4b,
			0xf469f437c0bfc104,
			0xf81b3789a4d0575d,
		},
		Compressed: true,
	})
}
